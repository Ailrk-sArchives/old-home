<h1>Intro to computabilities</h1>
<h2>Computable functions.</h2>
<h2>Works on computable functions</h2>
<ul>
<li>Kurt Godel: created general recursive functions.</li>
<li>Alonzo Church: Created Lambda calculus. A function on natural numbers is called <strong>λ-computable</strong> if it can be computed by lambda calculus</li>
<li>Alan Turing: Craete Turning machine. A function is <strong>turing computable</strong> if it can be computed by a turing machine</li>
</ul>
<p>Later it's proved that this three systems are equivalent.</p>
<h2>Turing completeness</h2>
<p>A computational model that can be implemented by any turing machine.</p>
<h2>Turing equivalence</h2>
<p>Two computers P and Q are called equivalent if P can simulate Q and Q can simulate P.</p>
<h2>Church-Turing thesis (What is computable)</h2>
<p>Any functions whoes value can be computed by an algorithm can be computed by a turing machine.</p>
<p>Formal version: A function on the natural numbers can be calculated by an effective method iff it's computable by a turing machine.</p>
<h2>General recursive functions --</h2>
<p>General recursive functions are partial functions that take finite tuples of natural numbers and return a single natural number.</p>
<p>General recursive functions are the smallest class of partial funtions that includes the initial functions and is <strong>closed under composition, primitive recursion and μ operator</strong>.</p>
<h4>Total function and parital functions</h4>
<ul>
<li>Integer multiplication (a, b) = a * b is a <strong>total function</strong> of ℤ² → ℤ, because all elements in it's domain will have a correspondence in the codomain.</li>
<li>Integer division (a, b) = ⌊a / b⌋ is a <strong>parital function</strong> of ℤ² ⇀ ℤ (Notice the half arrow), because not all elements in the domain has result in codomain. E.g (a / 0) is not defined.</li>
</ul>
<h4>Primitive recursive function (function that can be computed by for loops..)</h4>
<p>Functions that can be computed with a known upper bound of the number of iteration before entering the loop.</p>
<ul>
<li>Most function we care in mathematics in general are primitive recursive functions (+, /, factorial, exp...)</li>
</ul>
<p>PS: n-ary function means the function takes n parameters.</p>
<h5>Definitions</h5>
<p>Note primitive recursive functions are defined on natural numbers.</p>
<ul>
<li>Primitive recursive functions known <strong>by axioms</strong>
<ul>
<li><strong>1</strong>. <strong>Zero Constant function</strong> (zero): 0-ary functions <code>f() = 0</code></li>
<li><strong>2</strong>. <strong>Successor fuction (succ)</strong> : 1-ary functions <code>S(k) = k + 1</code> where k ∈ ℕ (Peano natural numbers)</li>
<li><strong>3</strong>. <strong>Projection function</strong>: <code>Pᵢ(x₁, x₂, ..., xₙ) = xᵢ</code> where i &lt; n, i, n ∈ ℕ</li>
</ul>
</li>
<li>More complex primitive recursive functions
<ul>
<li>
<ol start="4">
<li><strong>Composition (∘)</strong>: For k-ary primitive recursive function f and k many m-ary primitive recursive function g₁ to gₖ, then `h(x₁, ..., xₘ) = f(g₁(x1, ..., xₘ), ..., gₖ(x1, ..., xm))`` is also primitive recursive.</li>
</ol>
</li>
<li>
<ol start="5">
<li><strong>Primitive recursive (ρ)</strong>: let f be a k-ary primitive recursive function, and g be a (k+2)-ary primitive recursive function. the (k+1)-ary function h is defined as the primitive recursion of f and g. E.g the function h is primitive recursive when <code>h(0, x₁, x₂, ..., xₖ) = f(x₁, ..., xₖ)</code> and <code>h(succ(y), x₁, ..., xₖ) = g(y, h(y, x₁, ..., x), x₁, x₂, ..., xₖ)</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<p>PS: <strong>Composition</strong> is defined on a function and a set of functions that yields it's parameters.</p>
<p>PS: Projection functions is used to select argument of one function to other functions.</p>
<pre><code>-- Primitive recurisive function.
-- Notice this is not a formal primitive recursive definition.
-- "Wiring" parameters is not part of the axioms
f(a, b, c) = g(h(c, a) , h(a, b))

-- formal primitive recursive definition with
-- components and projections:
f(a, b, c) = g(h(proj₃³(a, b, c), proj₁³(a, b, c)),
               h(proj₁³(a, b, c), proj₂³(a, b, c)))
</code></pre>
<p>PS: <strong>Primitive recursion</strong></p>
<pre><code>Let's define
    f : ℕⁿ ⇀  ℕ, g: ℕⁿ⁺² ⇀ ℕ (notice the paritial function)
    h = ρⁿ(f, g) : ℕⁿ⁺¹ ⇀ ℕ

First look at the name you knwo its about recursion.
Base case:
    h(0, x₁, x₂, ..., xₖ) = f(x₁, ..., xₖ)
Recursive step:
    h(succ(y), x₁, ..., xₖ) = g(y, h(y, x₁, ..., x), x₁, x₂, ..., xₖ)

function g takes two more input than the base case f. Namely the final input y to h and the recursive call h(y, x₁, ..., x).
</code></pre>
<h5>Some examples.</h5>
<p>Note for primitive recursion different books will use different orders. We use this order:</p>
<pre><code>-- Base case:
--     h(0, x₁, x₂, ..., xₖ) = f(x₁, ..., xₖ)
-- Recursive step:
--     h(succ(y), x₁, ..., xₖ) = g(y, h(y, x₁, ..., x), x₁, x₂, ..., xₖ)
-- where y is the final input,
--       h is the recursive call.
</code></pre>
<p>Some basic examples:</p>
<pre><code>one : ℕ → ℕ
one = succ ∘ zero

four : ℕ → ℕ
four = succ ∘ succ ∘ succ ∘ succ ∘ zero
</code></pre>
<p>you can compose with multiple functions as long as the arity matches up.</p>
<pre><code>plusFour : ℕ → ℕ
plusFour = add ∘ [proj₁¹, four]

-- using composition and projection to select argument.
addFirstAndThird : ℕ³ → ℕ
addFirstAndThird = add ∘ [proj₁³, proj₃³]

</code></pre>
<p>This uses primtive recursion. Something to be aware of:</p>
<ul>
<li>You can't just directly &quot;wire&quot; parameters around, instead you compose with the projection</li>
</ul>
<pre><code>add : ℕ² → ℕ
add = ρⁿ(proj₁¹, succ ∘ [proj₂³])

-- Another way to define it
add' : ℕ² → ℕ
add' (0, x) = x
add' (succ(n), x) = succ(proj₂³(n, add(n, x), x))

-- Another definition with primitive recursion
mult : ℕ² → ℕ
mult = ρ¹(zero, add ∘ [proj₂³, proj₃³])
-- note
-- first for base case f : ℕ → ℕ, mult(x, 0) = 0. so f = zero
-- then for recursive step, mult(x, y+1) = x + mult(x, y)
-- g : ℕ³ → ℕ = g(x₁, x₂, x₃) = g(y, x, mult(x, y))

-- predcessor
pred : ℕ → ℕ
pred = ρ₀(zero, proj₁²)

pred' : ℕ → ℕ
pred' (zero) = zero
pred' (succ(n)) = proj₁²(n, pred'(n))
</code></pre>
<h2>Turing machine --</h2>
<h2>Lambda Calculus --</h2>
