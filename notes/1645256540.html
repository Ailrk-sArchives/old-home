<h1>Typescript moduels, async in react.</h1>
<h2>moduels in typescript</h2>
<h5>1. modules execute on their own scope</h5>
<p>Like all modern module systems. If all functions are pure then the module is just a namespace. But if there is state, since the module is scoped it can serve as a container, avoiding global state.</p>
<h5>2. ECMAScript</h5>
<p>Any file containing top-level import or export is considered a module. Otherwise the file is treated as a script.</p>
<h5>3. re-export doesn't import value locally.</h5>
<p>Re-export simply propagate the value to the next import.</p>
<h5>4. export * from &quot;module&quot;;</h5>
<p>Export everthing. This can be used as top level export.</p>
<h5>5. import for side effects.</h5>
<p>If a module has no export, import it will simply execute it. It's useful for setting up an environment.</p>
<h5>6. barrel.</h5>
<p>Re-exporting everything in index.ts.</p>
<h2>async in react.</h2>
<p>Async requets can cause some problems in react component.</p>
<h5>1. Async response can arrive after a component is teared down.</h5>
<p>Async response can arrive after the component is unmounted. This will cause a react's runtime exception, which is an error message. Not a big deal but it can be better.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">const</span> ismounted = useRef&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">true</span>);

useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { ismounted.current = <span class="hljs-literal">false</span>; };
}, []);

useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> f = <span class="hljs-keyword">async</span> () =&gt; { <span class="hljs-keyword">if</span> (ismounted.current) setValue(<span class="hljs-keyword">await</span> ...); }
}, []);
</code></pre>
<h5>2. Race condition</h5>
<p><code>useEffect</code> can depend on some prop, and when the prop update useEffect might send the async request again before the previous reuqest resolved. If the second request arrive eariler it will cause a race condition. Solution is to cancel the previous request when sending a new request. Or maybe use sequence number?</p>
<h2>Code splitting</h2>
<p>Webpack allows code splitting, which means it bundles your code into chunks, and each chunk and be download asynchronously. This allows to load a fast-to-load minial bundle, and adding more bundle asynchronously after that. So for instance in <code>create-react-app</code>, as long as there are no static files in <code>public</code> folder all codes will eventually be delivered to client side. But with code splitting this can happen in a non blocking manner so the load time doesn't feel so long.</p>
<h2>Link Local npm package</h2>
<p>If you have two local package and one depends on another, you can use <code>npm link</code>. First create a global link in the library that is depended by running <code>npm link</code>, and in the package that depends on the first package run <code>npm link &lt;dependency&gt;</code>.</p>
<h5>caveats</h5>
<p><code>npm link</code> doesn't auto compile. Everytime you changed your dependency you need to manually relink it to global sym links, and link from the main project again.</p>
<h2>Iterator and IterableIterator...</h2>
<h5>Iterator&lt;T&gt;, IteratorResult&lt;T&gt;</h5>
<h5>Down level iteration for ES5</h5>
<p>An iteration over array or string will be simply compiled to a simple loop, but for a general iterator the compiler will needs to shove an entire implementation of the iterator protocol, which can bloat the code size.</p>
