-- tag rust gdb cargo haskell
-- title Note: Some rust debugging, some haskell.
-- date 2020-07-25
-- source https://whamcloud.github.io/Online-Help/docs/Contributor_Docs/cd_Debugging_Rust_Tests.html
          https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/ghci-debugger.html
;;
# Some rust debugging, some haskell.
1. rust debugging?
    rust havs pretty good gdb support. Binary built from rustc can use geb directly. Also you can
    debug test. info locals` doesn't seems to work for some reasons but not a big deal.

2. where do I find things in cargo project(binary etc)?
    binary are in `debug/`. There is a binary file at the top level, which is the entire program.
    If you want to debug test you can find it in deps. To know exactly which file is for test,
    run `cargo test` first to find out the path to the binary.

3. haskell debugging?
    Because you have a interpreter, most of the technics for python also works here. Besides that
    `ghci` is also a debugger, you can set break point and other stuffs. It is very hard to use,
    e.g commands are hard to type and it's hard to follow the execution since haskell is lazyness by default,
    your execution path is not necessary follows the lexical scope.
    For print output there is `Debug.Trace` module which you can insert into any part of an expression.
    It is awkward to use because it messes up with the original code structure. Each time you're done
    debugging you need to reformat the code. Formatter solve the problem to some extends, I feel you can
    get used to it if you do it very often.

4. some wishes for ghci
    A TUI will be very useful. I don't know how people debug with gdb alone before TUI was a thing.
    constantly list code with `l` command just seems so inefficient.
    Or could there be a universal functional languages debugger for all languages based on lambda calculus?

# Some experiences about codeWar
1. How to assess the difficulty of a problem?
    Sometimes rank of the problem doesn't really reflect the difficulty. Or maybe some problems requires some
    domain knowledges, and depends on your experiences it might be harder/easier for you.
    In general if you cannot solve a problem in 5 minutes you might need 1 hour. If 1 hour doesn't make it
    means it is a really hard problem, and it could takes hours to days.

2. What's the process for solving a problem?
    If a problem cannot be solved in 3 minutes, it's better to look at the problem carefully and plan some
    possible paths before write code. There had been a lot of times that I realize the whole solution is
    wrong when I about to finish it. Some problems have smarter solutions which can drastically simplify coding
    process, but if you start writing code too early you can simply miss those at the beginning.

3. How to deal with problems with lots of cases?
    If you sense a problem needs to split into muiltiple cases that you can no longer hold all of them in your head
    at once, the first thing to do is to write down all cases, or some typical cases down. A list of all cases is
    static and easier to reason about. Some problems have more hidden cases than you think.

# Something to say about haskell
1. Binding?
    Don't write super long expression, but making binding for multiple small componentes. I used to think a
    long long expression with 20 functions involved is the higher ground of functional programming. But in
    fact naming things is still as valid as good old other languages. Trying to think naming as the most
    fundamental abstraction technic.

2. do notation?
    Some people against it, because they think do notation hide the functional nature of monad chaining,
    but I think it is good. It makes code significantly neater. Functional programming have lots
    of benefits, but readability is not part of it. No matter how much of a fan boy I find it is hard to
    convince myself a 3 line long expression looks better than a 20 line block with each line do a simple
    thing (This is a type of composibility I thinkt?).

3. translate imperitive code
    Biggest problem I had so far is to translate some function with a for loop which break eailer. I found
    foldl and scanl are a good way to simulate those behaviors.

4. neater code with function composition
    Compose function as much has you can. A composed function is easy to read, and once the function is valid
    you can stop worring about the type because all internals algined already, the only type you stil care
    is input and output, which makes the program eaiser to follow.

5. use lsp?
    You can using `_` as typehole to infer the type, or just simply check if something has the right type.
    These feature really improve the ergonomics in my opinion.

6. first class function?
    It actual means more than you can return or pass a function. Now functions are data, it's Functor that you can
    map into; it's Applicative you can lift over; Reader is actual function, State is actual function, Parser combinators
    are all functions etc.

7. Language extensions?
    Haven't use a lot. Some syntatic extensions are not that interesting, and you can live well without it. List some
    I used: `GADTs` make agda stype data declarations. `RankNTypes` give your scope for forall, Template haskell and quasi
    quote for meta programming and DSL.

8. Math?
    Abstract algebra and logics are so far the most helpful ones. I don't know much about cat theory, and only scratched
    the surface of type theory. Theses are next goal.

# Somethig to say about rust.
1. General chaining style?
    `methods` are more like syntatic sugar for working with a struct. In haskell you can curry stuffs so
    it is not strictly necessary, but for rust it improves the

2. Take ownership in method chain

3. reference in struct make lifetime contigous.

4. use inference wisely.

5. module system

6. monad and Result.

7. Performance of iterator and for loop

8. coericion and casting

9. Iterator based stuffs

10. Don't abuse traits
    Bad abstraction trips you more than no abstraction.
    Abstractions are based on something. If the underlying model is not clear,
    the abstraction can be very clumsy.

