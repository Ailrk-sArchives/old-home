<h1>Haskell idioms</h1>
<p>Some commonly seen haskell idioms. I found this blog post very insteresting. There was a similar article <a href="https://github.com/mcinglis/c-style">for C</a>. This note is just some practices and code snippets. I found this type of articles is very userful for people who already know core concepts of a language but want to be better at it.</p>
<p>Besides examples and exercises in the article, I also make some notes about part of haskell I didn't encounter before.</p>
<h2>Newtype</h2>
<h4>Description</h4>
<p>Use <code>newtype</code> as lightweight data wrapper to represent semantically different data. For example, <code>String</code> vs <code>Password</code> vs <code>Username</code>. Wrapping data with newtype allows you to implement more typeclass wihtout affect the data get wrapped. Besides, you can also derive typeclass the wrapped data already defined.</p>
<p>Compiler will use <code>newtype</code> types for type checking only, and the wrapper will be erased in the final binary, so it's a haskell zero cost abstraction.</p>
<h4>Example</h4>
<p>Newtype accept only one parameter for it's data constructor.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">PasswordHash</span> = <span class="hljs-type">PasswordHash</span> <span class="hljs-type">ByteString</span></span>
<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Password</span> = <span class="hljs-type">Password</span> {
    <span class="hljs-title">unPassword</span> :: <span class="hljs-type">ByteString</span>
}</span>
<span class="hljs-title">validate</span> :: <span class="hljs-type">Password</span> -&gt; <span class="hljs-type">PasswordHash</span> -&gt; <span class="hljs-type">Bool</span>
<span class="hljs-title">validate</span> = bool
</code></pre>
<p>Because <code>password</code> and <code>passwordHash</code> are <code>newtype</code>, compiler is aware of them as different types. On another hand, if you simply give them a alias by using <code>type</code>, error message will treate all of them as <code>ByteString</code>, not necessarily pretty.</p>
<h2>Smart constructor</h2>
<h4>Description</h4>
<p>Haskell idiom for constructing values. Essentaily a function only used to creates a data type. You read ppl's code and see a function named <code>mk..</code> and return a Maybe or Either, those are smart construtors. Smart construtor helps to separate concerns and make illegal states unrepresentable.</p>
<h4>Example</h4>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Password</span> = <span class="hljs-type">Password</span> <span class="hljs-type">ByteString</span></span>

<span class="hljs-title">unPasword</span> :: <span class="hljs-type">Password</span> -&gt; <span class="hljs-type">ByteString</span>
<span class="hljs-title">unPasword</span> (<span class="hljs-type">Password</span> password) = password

<span class="hljs-comment">-- smart constructor</span>
<span class="hljs-title">mkPassword</span> :: <span class="hljs-type">ByteString</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Password</span>
<span class="hljs-title">mkPassword</span> pwd
    | <span class="hljs-type">ByteString</span>.null pwd = <span class="hljs-type">Nothing</span>
    | otherwise = <span class="hljs-type">Just</span>(<span class="hljs-type">Password</span> pwd)
</code></pre>
<p>mkPassword gives another layer of validation and make sure the data it construct make sense. If all passwords are made from mkPassword then there will be no empty password in the program.</p>
<pre><code class="language-haskell"><span class="hljs-keyword">import</span> Control.Applicative (<span class="hljs-title">liftA2</span>)
<span class="hljs-keyword">import</span> Data.List.NoEmpty (<span class="hljs-type">NonEmpty</span> (..))
<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Tag</span> = <span class="hljs-type">Tag</span> <span class="hljs-type">String</span></span>
<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">TagList</span> = <span class="hljs-type">Taglist</span> (<span class="hljs-type">NonEmpty</span> <span class="hljs-type">Tag</span>)</span>

<span class="hljs-title">mkTag</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Either</span> <span class="hljs-type">String</span> <span class="hljs-type">Tag</span>
<span class="hljs-title">mkTag</span> tag
    | null tag = error <span class="hljs-string">"Empty Tag"</span>
    | otherwise = <span class="hljs-type">Tag</span> tag

<span class="hljs-title">unTagList</span> :: <span class="hljs-type">TagList</span> -&gt; <span class="hljs-type">NonEmpty</span> <span class="hljs-type">Tag</span>
<span class="hljs-title">unTagList</span> (<span class="hljs-type">TagList</span> taglist) = taglist

<span class="hljs-title">mkTagList</span> :: [<span class="hljs-type">String</span>] -&gt; <span class="hljs-type">Either</span> <span class="hljs-type">String</span> <span class="hljs-type">TagList</span>
<span class="hljs-title">mkTagLsts</span> [] = <span class="hljs-type">Left</span> <span class="hljs-string">"Empty"</span>
<span class="hljs-title">mkTagList</span> (tag:tags) =
  <span class="hljs-type">TagList</span> &lt;$&gt; liftA2 (:|) (mkTag tag) (traverse) mkTag tags
</code></pre>
<h4>PS</h4>
<p>Note traverse is just fmap then sequence. <code>(:|)</code> is the constructor for <code>Data.List.NonEmpty</code>. <code>Data.List.NonEmpty</code> is a list that always has at least one element. (Except that it's exactly the same as a normal List).</p>
<h4>PS</h4>
<p><code>(traverse) mkTag tags</code> fmap then sequence. If <code>t</code> is traversable and <code>f</code> is applicative, the result of traverse is <code>f (t a)</code>. In this case it produce <code>Either String [Tag]</code></p>
<p><code>liftA2</code> is a applicative lifting, it lifts <code>(:|)</code> into <code>(mkTag tag) :: Either String Tag</code> and makes partially applied function inside the applicative. Assume no errors happen, <code>Either String</code> shoule be <code>Right</code>, thus we have <code>Right ((mkTag Tag) (:|))</code>. <code>liftA2</code> will apply it with the <code>Either String [Tag]</code> formed by the traverse, so the final result is we cons the first tag to the rest of the tags.</p>
<h2>Evidence</h2>
<h4>Description</h4>
<p>Replace boolean blindness with the validation witness. (But what is boolean blindness? What is validation witness?)</p>
<h6>Bool Blindness</h6>
<p>The situtation that you are using a if expression and boolean to test a data, and if it's ture do some operation on it. But after you passed the boolean check, you lose the checked information in the then scope. For example:</p>
<pre><code class="language-haskell"><span class="hljs-title">and</span> :: (a -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span>) -&gt; (a -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span>) -&gt; a -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span>
<span class="hljs-title">and</span> f g x =
  <span class="hljs-keyword">if</span> isNothing (f x) || isNothing (g x) <span class="hljs-keyword">then</span> <span class="hljs-type">Nohting</span>
    <span class="hljs-keyword">else</span> <span class="hljs-type">Just</span> $ fromJust (f x) + fromJust (g x)
</code></pre>
<p>You see the <code>fromJust</code> is copmpletely unnecessary since you already know <code>f x</code> is not Nothing.</p>
<h6>Validation Witness</h6>
<p>Basically telling you to use pattern matching. Or write your code in a way that the data in the branch is been narrowed to a specific case, so you are aware of the effort put on validation.</p>
<h4>Example</h4>
<pre><code class="language-haskell"><span class="hljs-comment">-- opaque data type that only been create with validateHash</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">UserAuth</span></span>
<span class="hljs-title">validateHash</span> :: <span class="hljs-type">Password</span> -&gt; <span class="hljs-type">PasswordHash</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">UserAuth</span>

<span class="hljs-title">accessDenied</span> :: <span class="hljs-type">User</span> -&gt; <span class="hljs-type">IO</span> <span class="hljs-type">Page</span>
<span class="hljs-title">getUserPage</span> :: <span class="hljs-type">UserAuth</span> -&gt; <span class="hljs-type">User</span> -&gt; <span class="hljs-type">IO</span> <span class="hljs-type">Page</span>

<span class="hljs-title">loginUser</span> :: <span class="hljs-type">User</span> -&gt; <span class="hljs-type">Password</span> -&gt; <span class="hljs-type">PasswordHash</span> -&gt; <span class="hljs-type">IO</span> <span class="hljs-type">Page</span>
<span class="hljs-title">loginUser</span> user pwd pwdHash = <span class="hljs-keyword">case</span> validateHash pwd pwdHash <span class="hljs-keyword">of</span>
  <span class="hljs-type">Nothing</span> -&gt; accessDenied user
  <span class="hljs-type">Just</span> auth -&gt; getUserPage auth user
</code></pre>
<h2>Make illegal states unrepresentable</h2>
<h4>Description</h4>
<p>The point of using smart constructor and evidence is to make illegal states unrepresentable. You want to write your code so a error state can't happen.</p>
<h4>Example</h4>
<pre><code class="language-haskell"><span class="hljs-comment">-- Bad</span>
<span class="hljs-title">handleTwoOptionals</span> :: <span class="hljs-type">Maybe</span> a -&gt; <span class="hljs-type">Maybe</span> b -&gt; <span class="hljs-type">IO</span> ()
<span class="hljs-title">handleTwoOptionals</span> (<span class="hljs-type">Just</span> a) (<span class="hljs-type">Just</span> b) = ...
<span class="hljs-title">handleTwoOptionals</span> <span class="hljs-type">Nothing</span> <span class="hljs-type">Nothing</span> = <span class="hljs-type">No</span> value...
<span class="hljs-title">handleTwoOptionals</span> _ _ = error ...
</code></pre>
<p>This is a bad exmaple, there are two cases you don't need anyway. Why don't just make it a tuple.</p>
<p>Like this:</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- Good</span>
<span class="hljs-title">handleTwoOptionals</span> :: <span class="hljs-type">Maybe</span> (a, b) -&gt; <span class="hljs-type">IO</span> ()
<span class="hljs-title">handleTwoOptionals</span> (<span class="hljs-type">Just</span> (a, b)) = ...
<span class="hljs-title">handleTwoOptionals</span> <span class="hljs-type">Nothing</span> = <span class="hljs-type">No</span> value...
</code></pre>
<p>You are expressing the same thing with less input state possible.</p>
<p>So a rule of thumb is to limit the amount of state possible, just like how you always try to make scope smaller.</p>
<h2>Phantom type parameters</h2>
<h4>Description</h4>
<p>Phantom type doesn't have a value in the term level. You can phantom type parameter to indicate different usage of a newtype.</p>
<h4>Example</h4>
<pre><code class="language-haskell"><span class="hljs-comment">-- specify what id it is</span>
<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Id</span> a = <span class="hljs-type">Id</span> { <span class="hljs-title">unId</span> :: <span class="hljs-type">Int</span> }</span>
<span class="hljs-title">isCommentByUser</span> :: <span class="hljs-type">Id</span> <span class="hljs-type">User</span> -&gt; <span class="hljs-type">Id</span> <span class="hljs-type">Comment</span> -&gt; <span class="hljs-type">Bool</span>

<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Password</span> a = <span class="hljs-type">Password</span> { <span class="hljs-title">unPassword</span> :: <span class="hljs-type">ByteString</span> }</span>
<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">PasswordHash</span> a =</span>
    <span class="hljs-type">PasswordHash</span> { unPasswordHash :: <span class="hljs-type">ByteString</span> }

<span class="hljs-comment">-- You can express the passwordHash is for the same type of</span>
<span class="hljs-comment">-- password</span>
<span class="hljs-title">mkPassword</span> :: <span class="hljs-type">Password</span> a -&gt;  <span class="hljs-type">Maybe</span> (<span class="hljs-type">PasswordHash</span> a)
</code></pre>
<p>Another example</p>
<pre><code class="language-haskell"><span class="hljs-keyword">import</span> Data.Binary (<span class="hljs-type">Binary</span>)
<span class="hljs-keyword">import</span> Data.ByteString

<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">PrivateKey</span> = <span class="hljs-type">PrivateKey</span> <span class="hljs-type">ByteString</span></span>
<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">PublicKey</span> = <span class="hljs-type">PublicKey</span> <span class="hljs-type">ByteString</span></span>
<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Signature</span> a = <span class="hljs-type">Signature</span> <span class="hljs-type">ByteString</span></span>

<span class="hljs-title">createPublicKey</span> :: <span class="hljs-type">PrivateKey</span> -&gt; <span class="hljs-type">PublicKey</span>
<span class="hljs-title">createPublicKey</span> = error <span class="hljs-string">"not implemented"</span>

<span class="hljs-title">sign</span> ::<span class="hljs-type">Binary</span> a =&gt; <span class="hljs-type">PrivateKey</span> -&gt; a -&gt; <span class="hljs-type">Signature</span> a
<span class="hljs-title">sign</span> = error <span class="hljs-string">"not implemented"</span>

<span class="hljs-title">verifySignature</span> ::
    <span class="hljs-type">Binary</span> a =&gt; <span class="hljs-type">PublicKey</span> -&gt; <span class="hljs-type">Signature</span> a -&gt; a -&gt;  <span class="hljs-type">Bool</span>
<span class="hljs-title">verifySignature</span> = error <span class="hljs-string">"Not implemented"</span>
</code></pre>
<p>This ensures that you cannot verify signature for a different type that the signature was created initally.</p>
<h2>MonadFail Sugar</h2>
<h4>Description</h4>
<p>A way to handle nestesd pattern matching (or multiple parts of a data) when the reason of a particular failure is not important. Using MonadFail sugar you can get cleaner syntax for nested pattern matching while avoid creating partial functions. The least thing you want to have is make a partial function. It doesn't comply with the &quot;make illegal state unrepresentable&quot; rule, and it makes some potential runtime error implicit.</p>
<p><code>MonadFail</code> is a typeclass with only one function that helps to skip the failure case in a monad without needing you to manually write out the pattern matching.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">MonadFail</span> m <span class="hljs-keyword">where</span></span>
    fail :: <span class="hljs-type">String</span> -&gt; m a
<span class="hljs-type">MonadFail</span> fail the
</code></pre>
<p><code>MonadFail</code> is implemented for some commonly used datatypes.  For instance, <code>IO</code> and <code>Maybe</code>.</p>
<p>See the example how <code>do notation</code> in a <code>IO</code> monad get desugared. In the example, if the pattern matching in the fist line of the do notation failed, it will fall back to a fail branch implicitly. A failed pattern mathing in <code>IO</code> will cause a IO exception been thrown, and it is handled by the implementation of <code>MonadFail</code>.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- sugared code</span>
<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    [_, arg2] &lt;- getArgs
    print args2

<span class="hljs-comment">-- desugared</span>
<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = getArgs &gt;&gt;= \args -&gt; <span class="hljs-keyword">case</span> args <span class="hljs-keyword">of</span>
    [_, arg2] -&gt; print arg2
    _ -&gt; fail <span class="hljs-string">"Some compiler generated message"</span>
</code></pre>
<h4>Example</h4>
<pre><code class="language-haskell"><span class="hljs-title">bufferLastLine</span> :: <span class="hljs-type">Buffer</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">String</span>

<span class="hljs-title">cmdSequence</span> :: <span class="hljs-type">Buffer</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">String</span>
<span class="hljs-title">cmdSequence</span> buffer = <span class="hljs-keyword">do</span>
    line &lt;- bufferLastLine buffer
    [<span class="hljs-string">"CMD"</span>, number, cmd] &lt;- <span class="hljs-type">Just</span> $ words line
    <span class="hljs-number">42</span> &lt;- readMaybe number
    pure cmd
</code></pre>
<p>There is a change that  <code>Just $ words line</code> fail to pattern match with <code>[&quot;CMD&quot;, number, cmd]</code>, and that's ok, because <code>Maybe</code> implemented <code>MonadFail</code>, the do notation actually desugared into</p>
<pre><code class="language-haskell"><span class="hljs-title">cmdSequence</span> buffer = bufferLastLine buffer &gt;&gt;=
    \<span class="hljs-keyword">case</span>
        [<span class="hljs-string">"CMD"</span>, number, cmd] -&gt;
            readMaybe number &gt;&gt;= \<span class="hljs-keyword">case</span>
                <span class="hljs-number">42</span> -&gt; pure cmd
                _ -&gt; fail <span class="hljs-string">""</span>
        _ -&gt; fail <span class="hljs-string">""</span>
</code></pre>
<p>Some other examples. <code>readMaybe :: (Read a) =&gt; String -&gt; Maybe a</code></p>
<pre><code class="language-haskell"><span class="hljs-keyword">import</span> Text.Read (<span class="hljs-title">readMaybe</span>)

<span class="hljs-title">sumThree</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span>
<span class="hljs-title">sumThree</span> s = <span class="hljs-keyword">do</span>
    [a, b, c] &lt;- traverse readMaybe $ words s
    pure $ a + b + c

<span class="hljs-title">catMaybes</span> :: [<span class="hljs-type">Maybe</span> a] -&gt; [a]
<span class="hljs-title">catMaybes</span> xs = [x | <span class="hljs-type">Just</span> x &lt;- xs]

<span class="hljs-title">mapMaybe</span> :: (a -&gt; <span class="hljs-type">Maybe</span> b) -&gt; [a] -&gt; [b]
<span class="hljs-title">mapMaybe</span> f xs =  [n | <span class="hljs-type">Just</span> n &lt;- (f &lt;$&gt; xs)]

<span class="hljs-comment">-- relies on that MonadFail sugar will handle our failure case.</span>
<span class="hljs-title">threeNothing</span> :: <span class="hljs-type">Maybe</span> a -&gt; <span class="hljs-type">Maybe</span> b -&gt; <span class="hljs-type">Maybe</span> c -&gt; <span class="hljs-type">Maybe</span> ()
<span class="hljs-title">threeNothing</span> a b c = <span class="hljs-keyword">do</span>
    <span class="hljs-type">Nothing</span> &lt;- <span class="hljs-type">Just</span> a
    <span class="hljs-type">Nothing</span> &lt;- <span class="hljs-type">Just</span> b
    <span class="hljs-type">Nothing</span> &lt;- <span class="hljs-type">Just</span> c
    pure ()
</code></pre>
<p>Note, <code>MonadFail</code> is a rough way to handle error cases. It's good for <code>Maybe</code> and <code>IO</code> since you might not care about the reason why they fail. But if you have Monads report the exactly reason of a failure, like <code>Either e a</code> or <code>Validation</code>, manually handle failure cases is required.</p>
<h4>PS MonadFail and list comprehension</h4>
<p><code>MonadFail</code> for list comprehension helps pick values from a list. If the pattern matching is failed the value will simply not be included into the resulting list.</p>
<pre><code class="language-haskell"><span class="hljs-title">sameRight</span> :: [(<span class="hljs-type">Either</span> e1 <span class="hljs-type">Int</span>, <span class="hljs-type">Either</span> e2 <span class="hljs-type">Int</span>)] -&gt; [<span class="hljs-type">Int</span>]
<span class="hljs-title">sameRight</span> xs = [n | (<span class="hljs-type">Right</span> n, <span class="hljs-type">Right</span> n) &lt;- xs, n == m]
</code></pre>
<h2>Polymorphization</h2>
<h4>Description</h4>
<p>Make function parameters as generic as possible. Make a function more generic means less code for each ad hoc cases, and better reusability of the same function under different senarios. You see most typeclass are fully polymorhic, and that make them applicable for almost everything.</p>
<h4>Example</h4>
<p>This example shows how to make a already very generic function even more generic.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- ok</span>
<span class="hljs-title">partition</span> :: (a -&gt; <span class="hljs-type">Bool</span>) -&gt; [a] -&gt; ([a], [a])
<span class="hljs-comment">-- better</span>
<span class="hljs-title">partition</span> :: (a -&gt; <span class="hljs-type">Either</span> b c) -&gt; [a] -&gt; ([b], [c])
</code></pre>
<p>See how b and c can be the same type as a, but write the code this way allows us to differentiate which part of the tuple is the partion we filtered out, so more information can be stored in the type.</p>
<h4>PS</h4>
<p>The end goal is to encode as much information about the purpose of the code as possible into the type level while making it ass generic as possible. if a function only take concrete types, it is clear that there is a chance to make it polymorphic. But even for functions that are polymorphic, we can make it even more generic by introduce more type parameters for different roles.</p>
<p>Note, you might have different type parameters, but two different type parameters can totally refer to the same type. So that's why it's so common to introduce more type parameters, which covers the original case while enable new possibilities, in another word, more generic.</p>
<h2>Bidirectional parsing</h2>
<h4>Description</h4>
<p>For any bidirectional converstion by implement one direction and get the other one by free. Works whenever you have injective function function.</p>
<h4>Example</h4>
<p>Say you have enum, you can make a function to convert the enum value to a string. But besides that you also want to do the opposite, that is given a string and return it's corresponding enum value. We can do that without write another conversion function that covers all cases. Instead we can make a helper function to help us to make the inversion.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- inverseMap from `relude package`</span>
<span class="hljs-title">inverseMap</span> :: <span class="hljs-keyword">forall</span> e s. (<span class="hljs-type">Bounded</span> e, <span class="hljs-type">Enum</span> e, <span class="hljs-type">Ord</span> s)
    =&gt; (e -&gt; s) -&gt; s -&gt; <span class="hljs-type">Maybe</span> e
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Color</span> = <span class="hljs-type">Green</span> | <span class="hljs-type">Yellow</span> | <span class="hljs-type">Blue</span></span>
<span class="hljs-title">showColor</span> :: <span class="hljs-type">Color</span> -&gt; <span class="hljs-type">Text</span>
<span class="hljs-title">showColor</span> = \<span class="hljs-keyword">case</span>
    <span class="hljs-type">Green</span> -&gt; <span class="hljs-string">"Green"</span>
    <span class="hljs-type">Yellow</span> -&gt; <span class="hljs-string">"Yellow"</span>
    <span class="hljs-type">Blue</span> -&gt; <span class="hljs-string">"Blue"</span>
<span class="hljs-comment">-- bidirectional parsing with one function</span>
<span class="hljs-title">parseColor</span> :: <span class="hljs-type">Text</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Color</span>
<span class="hljs-title">parseColor</span> = inverseMap showColor
</code></pre>
<p>A complete example.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- provides a finder grained control over how instance maybe derived.</span>
<span class="hljs-meta">{-# LANGUAGE DerivingStrategies #-}</span>

<span class="hljs-comment">-- match on multiple patterns on parameter of lambda</span>
<span class="hljs-meta">{-# LANGUAGE LambdaCase #-}</span>

<span class="hljs-comment">-- Overload string literal to any `isString`</span>
<span class="hljs-meta">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="hljs-comment">-- Basically spreading operator.</span>
<span class="hljs-meta">{-# LANGUAGE RecordWildCards #-}</span>
<span class="hljs-type">Module</span> <span class="hljs-type">Bi</span> <span class="hljs-keyword">where</span>
<span class="hljs-keyword">import</span> Data.Text (<span class="hljs-type">Text</span>)
<span class="hljs-keyword">import</span> Relude.Extra.Enum (<span class="hljs-title">inverseMap</span>)
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Color</span> = <span class="hljs-type">Red</span> | <span class="hljs-type">Green</span> | <span class="hljs-type">Yellow</span></span>
    <span class="hljs-keyword">deriving</span> stock (<span class="hljs-type">Show</span>, <span class="hljs-type">Enum</span>, <span class="hljs-type">Bounded</span>)
<span class="hljs-title">showColor</span> :: <span class="hljs-type">Color</span> -&gt; <span class="hljs-type">Text</span>
<span class="hljs-title">showColor</span> = \<span class="hljs-keyword">case</span>
    <span class="hljs-type">Red</span> -&gt; <span class="hljs-string">"red"</span>
    <span class="hljs-type">Green</span> -&gt; <span class="hljs-string">"green"</span>
    <span class="hljs-type">Yellow</span> -&gt; <span class="hljs-string">"yellow"</span>
    <span class="hljs-type">Blue</span> -&gt; <span class="hljs-string">"blue"</span>

<span class="hljs-title">parseColor</span> :: <span class="hljs-type">Text</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Color</span>
<span class="hljs-title">parseColor</span> = inverseMap showColor

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">FruitName</span> = <span class="hljs-type">Apple</span> | <span class="hljs-type">Orange</span> | <span class="hljs-type">Lemon</span> | <span class="hljs-type">Blueberry</span></span>
    <span class="hljs-keyword">deriving</span> stock (<span class="hljs-type">Show</span>, <span class="hljs-type">Enum</span>, <span class="hljs-type">Bounded</span>)

<span class="hljs-title">showFruitName</span> :: <span class="hljs-type">FruitName</span> -&gt; <span class="hljs-type">Text</span>
<span class="hljs-title">showFruitName</span> = \<span class="hljs-keyword">case</span>
    <span class="hljs-type">Apple</span> -&gt; <span class="hljs-string">"apple"</span>
    <span class="hljs-type">Orange</span> -&gt; <span class="hljs-string">"orange"</span>
    <span class="hljs-type">Lemon</span> -&gt; <span class="hljs-string">"lemon"</span>
    <span class="hljs-type">Blueberry</span> -&gt; <span class="hljs-string">"blueberry"</span>

<span class="hljs-title">parseFruitName</span> :: <span class="hljs-type">Text</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">FruitName</span>
<span class="hljs-title">parseFruitName</span> = inverseMap showFruitName

<span class="hljs-comment">-- strictly evaluated</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Fruit</span> = <span class="hljs-type">Fruit</span> {
    <span class="hljs-title">fruitColor</span> :: !<span class="hljs-type">Color</span>
    <span class="hljs-title">fruitName</span> :: !<span class="hljs-type">FruitName</span>
} <span class="hljs-keyword">deriving</span> stock (<span class="hljs-type">Show</span>)</span>

<span class="hljs-title">parseFruit</span> :: <span class="hljs-type">Text</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Fruit</span>
<span class="hljs-title">parseFruit</span> t = <span class="hljs-keyword">do</span>
    <span class="hljs-comment">-- pattern matching which fail case handled by MonadFail</span>
    [color, name] &lt;- <span class="hljs-type">Just</span> $ <span class="hljs-type">Text</span>.words t
    fruitColor &lt;- parseColor color
    fruitName &lt;- parseFruitName name
    pure <span class="hljs-type">Fruit</span>{..}  <span class="hljs-comment">-- From RecordWildCards extensions</span>
                    <span class="hljs-comment">-- fit fruitName and fruitColor directly.</span>
</code></pre>
<h2>Recursive go</h2>
<h4>Description</h4>
<p>Moving recursion over data types into another function. By doing so you can have the recursion function pass some parameters down as extra information without expose this detail to the caller of the interface.</p>
<h4>Example</h4>
<pre><code class="language-haskell"><span class="hljs-comment">-- accumulator i is not exposed to the external world.</span>
<span class="hljs-title">atGo</span> :: [a] -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Maybe</span> a
<span class="hljs-title">l</span> `atGo` n = go <span class="hljs-number">0</span> l
    <span class="hljs-keyword">where</span>
        go :: <span class="hljs-type">Int</span> -&gt; [a] -&gt; <span class="hljs-type">Maybe</span> a
        go _ [] = <span class="hljs-type">Nothing</span>
        go i (x:xs) = <span class="hljs-keyword">if</span> i == n <span class="hljs-keyword">then</span> <span class="hljs-type">Just</span> x <span class="hljs-keyword">else</span> go (i + <span class="hljs-number">1</span>) xs
</code></pre>
