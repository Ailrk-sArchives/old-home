<h1>GHC Extensions.</h1>
<h2>Sweet GHC extensions (sugars)</h2>
<h5>{-# LANGUAGE LambdaCase #-}</h5>
<p>Pattern match on the parameter of a lambda function directly. It saves you from nameing the parameter.</p>
<pre><code class="language-haskell"><span class="hljs-title">f</span> x :: <span class="hljs-type">Maybe</span> a -&gt; <span class="hljs-type">Maybe</span> a
<span class="hljs-title">f</span> = \<span class="hljs-keyword">case</span>
    <span class="hljs-type">Just</span> a -&gt; <span class="hljs-type">Just</span> a
    <span class="hljs-type">Nothing</span> -&gt; <span class="hljs-type">Nothing</span>
</code></pre>
<h5>{-# LANGUAGE OverloadedStrings #-}</h5>
<p>Polymorphic string over <code>Text</code> and <code>ByteString</code>.</p>
<p>Bascially allows you to have a function <code>f :: ByteString -&gt; Int</code>, and call it like <code>f &quot;good&quot;</code>. This is natural for numbers because number literals are by default polymorphic. However it doesn't comes by default for String.</p>
<h5>{-# LANGUAGE RecordWildCards #-}</h5>
<p>Allowing to use wildcard in record construction and pattern matching. This extension implies <code>DisambiguateRecordFields</code>. <code>..</code> can be used in a record like <code>f (C {a = 1, b, ..}) = b + c + d</code> where a will be updated to a and other part in the record will be the same.</p>
<p>The record wildcard expension will refer to the nearest enclosing variables that has the same name as some record field.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- spread</span>
<span class="hljs-type">C</span> {a = <span class="hljs-number">1</span>, ..} = e
<span class="hljs-comment">-- in expression</span>
<span class="hljs-title">let</span> {a = <span class="hljs-number">1</span>; b = <span class="hljs-number">2</span>; c = <span class="hljs-number">3</span>; d = <span class="hljs-number">4</span>} <span class="hljs-keyword">in</span> <span class="hljs-type">C</span> {..}
<span class="hljs-comment">-- the same as</span>
<span class="hljs-title">let</span> {a = <span class="hljs-number">1</span>; b = <span class="hljs-number">2</span>; c = <span class="hljs-number">3</span>; d = <span class="hljs-number">4</span>} <span class="hljs-keyword">in</span> <span class="hljs-type">C</span> {a=a, b=b, c=c, d=d};
</code></pre>
<h5>{-# LANGUAGE TupleSections #-}</h5>
<p>Translate a tuple like <code>(, &quot;I&quot;, , , &quot;Love, ,1335&quot;)</code> to <code>\a b c d -&gt; (a, &quot;I&quot;, b, c, &quot;Love, d, 1335&quot;)</code>. You have all kinds of extensions to provide nicer syntax for a very specific use case...</p>
<h5>{-# LANGUAGE MultiWayIf #-}</h5>
<p>Allow a guard-like if expression</p>
<pre><code class="language-haskell"><span class="hljs-title">if</span> | guard1 -&gt; expr1
   | ...
   | guardN -&gt; exprN
</code></pre>
<p>This is actually equivalent to</p>
<pre><code class="language-haskell"><span class="hljs-title">case</span> () <span class="hljs-keyword">of</span>
    _ | guard1 -&gt; expr1
     ...
    _ | guardN -&gt; exprN
</code></pre>
<h2>GHC extension for Safe haskell</h2>
<h5>What's the problem</h5>
<p>Haskell trys to separate pure and effectul functions through IO monad, but there are several loop holes in the type system that cn make impure functions in the pure section. For instance <code>unsafePerformIO :: IO a -&gt; a</code> can be a partial function and throw runtime exceptions. You want to avoid unsafe functions as much as possible, unless they are absolutely necessary, and <code>Safe Haskell</code> extension helps you to enforce this good style.</p>
<h5>Safe haskell</h5>
<p>Safe haskell is an extension that allows unsafe code be securely added into a code base by restricting features the code is allowed to use. It's like the <code>unsafe</code> block in rust. When you use stuffs like <code>unsafePerformIO</code> you can mark it as unsafe so it will be properly contained.</p>
<p>Safe hasekll ensure strict type safety. By default your haskell code can throw random exceptions, but with Safe haskell your safe code must be totally safe, and any code might throw exceptions should be contained in the unsafe sandbox.</p>
<p>A fact about safe haskell, it's an extension, but it runs in the background for each compilation by default. GHC use Safe haskell extension to tract the type violations of modules so it can infer the safety.</p>
<h5>examples</h5>
<p>This little module enabled the Safe extension. We want to ensure that the module exports codes that an untrusted code can import but cannot abuse. We are making a  plugin system that plugin authors could potentially be malicious third parties. With safe haskell we can either constraint that all plugins should be a pure function or to a restricted version of IO Momad (you can't perform certain IO Actions).</p>
<p>In the example below, we expose a RIO, which is the only IO monad that a plugin author can access, which voids them from executing arbitrary malicious code.</p>
<pre><code class="language-haskell"><span class="hljs-meta">{-# Language Safe #-}</span>
<span class="hljs-keyword">module</span> RIO (<span class="hljs-type">RIO</span>(), runRIO, rioReadFile, rioWriteFile) <span class="hljs-keyword">where</span>

<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">RIO</span> a = <span class="hljs-type">Unsafe</span> <span class="hljs-type">RIO</span> { <span class="hljs-title">runRIO</span> :: <span class="hljs-type">IO</span> <span class="hljs-title">a</span>}</span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> <span class="hljs-type">RIO</span> <span class="hljs-keyword">where</span></span>
  return = unsafeRIO . return
  (<span class="hljs-type">UnsafeRIO</span> m) &gt;&gt;= k = <span class="hljs-type">UnsafeRI</span> $ m &gt;= runRIO . k

<span class="hljs-title">pathOK</span> :: <span class="hljs-type">FilePath</span> -&gt; <span class="hljs-type">IO</span> <span class="hljs-type">Bool</span>
<span class="hljs-title">pathOK</span> file = erro <span class="hljs-string">"Unimplemented"</span>

<span class="hljs-title">rioReadFile</span> :: <span class="hljs-type">FilePath</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">RIO</span> ()
<span class="hljs-title">rioReadFile</span> file = <span class="hljs-type">Unsafe</span> <span class="hljs-type">RIO</span> $ <span class="hljs-keyword">do</span>
  ok &lt;- pathOK file
  <span class="hljs-keyword">if</span> ok <span class="hljs-keyword">then</span> readFile file <span class="hljs-keyword">else</span> return <span class="hljs-string">""</span>

<span class="hljs-title">rioWriteFile</span> :: <span class="hljs-type">FilePath</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">RIO</span> ()
<span class="hljs-title">rioWriteFile</span> file contents = <span class="hljs-type">UnsafeIO</span> $ <span class="hljs-keyword">do</span>
  ok &lt;- pathOK file
  <span class="hljs-keyword">if</span> ok <span class="hljs-keyword">then</span> writeFile file contents <span class="hljs-keyword">else</span> return ()
</code></pre>
<p>For instance you are the plugin author, you will use the RIO like this:</p>
<pre><code class="language-haskell"><span class="hljs-meta">{-# LANGUAGE Safe #-}</span>

<span class="hljs-title">runMe</span> :: <span class="hljs-type">RIO</span> ()
<span class="hljs-title">runMe</span> = ...
</code></pre>
<p>This is only possible with safe hasekll. The result:</p>
<ol>
<li>The author can access IO and write arbitrary IO actions anyway.</li>
<li>Besides that, the untrusted plugin author have no access to the <code>UnsafeIO</code> constructor; if you use template haskell you will still be able to access it, even it is not export at all.</li>
<li>There will be no restriction on what packages the plugin author can import. In that case the plugin author can just pick arbitrary library with some IO operation exposed and exploit that.</li>
</ol>
<h5>What is a safe language?</h5>
<p>Under Safe Haskell extension you wirte safe in a safe dialect of haskell. A safe language has several properties: <code>Referential transparency</code>, <code>Module boundary control</code>, <code>Semantic consistency</code>, and <code>Strict subset</code>. (buzz words in large).</p>
<h6>Referential transparency</h6>
<p>Any pure function is guaranteed to be pure. So all evaluation should be deterministic and won't cause any side effects. Exceptions are banned in this senario, so functions like <code>take</code> needs to take care about edge cases.</p>
<h6>Module boundary control</h6>
<p>Not everything are exported. Only things explicited stated on the export statement will be accessible by unsafe module.</p>
<h6>Semantic consistency</h6>
<p>Importing a Safe module will not chagne the meaning of existing code that doesn't depend on that module. So you should expect your normal code works as usual even you import some safe code.</p>
<h6>Strict subset</h6>
<p>The safe language is a strict subset of haskell. It's an implementation goal and basically everthing you expect to work should work.</p>
<h5>What are the restrictions under safe haskell?</h5>
<p>You can't use</p>
<ol>
<li><code>TemplateHaskell</code> since it can be used to gain access to constructors and adt that are not exported by a module.</li>
<li><code>ForeignFunctionInterface</code> FFI that iports function with non IO type is not allowed. (inherently unsafe code).</li>
<li><code>GenralisedNewtypeDeriving</code> It's possible to have self overlapping instances.</li>
<li><code>GHC.Generics</code></li>
</ol>
<h5>{-# LANGUAGE Safe #-}</h5>
<p>What does this actually do? This restruct the features of haskell that can be used to be a safe subet. Under the module with <code>(-# LANGUAGE Safe #-)</code> you can only rwrite safe dialect of haskell that we discussed above. Any module with <code>Safe</code> extension turned on will also restrict modules that can be imported by untrusted modules.</p>
<p>Trusted modules will be compiled with <code>{-# LANGUAGE Safe #-}</code>, and stuffs can be imported and exported freely among them.</p>
<pre><code class="language-haskell"><span class="hljs-keyword">import</span> safe <span class="hljs-keyword">qualified</span> Network.Socket <span class="hljs-keyword">as</span> NS
</code></pre>
<h5>{-# LANGUAGE UnSafe #-}</h5>
<p>If a module is marked as unsafe, it cannot by imported by safe code.</p>
<h5>{-# LANGUAGE TrustWorthy #-}</h5>
<p>It gives a module the permission of Safe module in terms of importing and exporting, but it doesn't actually apply any real restriction to functionalities been used. In safe haskell it's like those cowboy move you can put if you're confident about what you're doing.</p>
<h2>GHC extension for foreign function interface</h2>
<p>Call foreign functions in haskell. FFI is enabled by default, so strictly speaking it's not an extension. You can control ableness with <code>ForeignFunctionInterface</code> flag.</p>
<h4>Call safety</h4>
<p>Safe ffi calls must allow foreign calls to safely call into hasekll code, this means that the gc must be able to run while foreign calls are in progress.</p>
<p>If you pass a foreign heap objecet reference to haskell without any constraints, the gc will be able to move the reference arround the heap. A safe ffi requries your reference is <code>pinned</code>, so the gc can no longer move it arbitrarily.</p>
<p>I an <code>unsafe</code> call the foreign reference passed in doesn't required to be pinned, but after ghc 8.4 gc will never happen during a unsafe foreign call, so at least the heap itself won't move during the execution of the foreign call.</p>
<h4>UnliftedFFITypes</h4>
<p>Some basic foreign types <code>Int#</code>, <code>Word#</code>, <code>Char#</code>, <code>Float#</code>, <code>Double#</code>, <code>Addr#</code>, <code>StablePtr# a</code>.</p>
<p>Some boxed types can be used in foreign import with some restrictions.</p>
<h6>Types can be used as argument of <code>foreign import unsafe</code></h6>
<p><code>Array#</code>, <code>SmallArray#</code>, <code>ArrayArray#</code>, <code>ByteArray#</code>, <code>MutableArray#</code>, <code>MutableSmallArray#</code>, <code>MutableArrayArray#</code>, <code>MutableByteArray#</code></p>
<h6>Types can be used as argument of <code>foreign import safe</code></h6>
<p><strong>Pinned</strong> <code>ByteArray#</code>, <code>MutableByteArray</code>.</p>
<h6>Mutation</h6>
<p>It's safe to mutate <code>MutableByteArray</code> in both <code>safe</code> and <code>unsafe</code> foreign import.</p>
<h4>Example.</h4>
<p>Simple example. It sums the first three bytes without using anything from the <code>Rts.h</code> .</p>
<pre><code class="language-c"><span class="hljs-keyword">uint_8_t</span>  add_triplet(<span class="hljs-keyword">uint_8_t</span>* arr) {
    <span class="hljs-keyword">return</span> (arr[<span class="hljs-number">0</span>] + arr[<span class="hljs-number">1</span>] + arr[<span class="hljs-number">2</span>]);
}
</code></pre>
<pre><code class="language-haskell"><span class="hljs-title">foregin</span> <span class="hljs-keyword">import</span> ccall unsafe "add_triplet"
    addTriplet :: <span class="hljs-type">MutableArray</span># <span class="hljs-type">RealWorld</span> -&gt; <span class="hljs-type">IO</span> <span class="hljs-type">Word</span> <span class="hljs-number">8</span>
</code></pre>
<p>Sometimes your foreign language needs to know the rts closure type. In the following example the <code>StgArrayBytes</code> is a rts construct.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Rts.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum_first</span><span class="hljs-params">(StgArrayBytes **bufs)</span> </span>{
    StgArrayBytes **bufs = (StgArrayBytes**)bufsTmp;
    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (StgWord ix = <span class="hljs-number">0</span>; ix &lt; arr-&gt;ptrs; ix++) {
    res = res + ((<span class="hljs-keyword">int</span>*)(bufs[ix]-&gt;payload)[<span class="hljs-number">0</span>]);
    }
    <span class="hljs-keyword">return</span> res;
}
</code></pre>
<pre><code class="language-haskell"><span class="hljs-comment">--</span>
<span class="hljs-title">foregin</span> <span class="hljs-keyword">import</span> ccall unsafe "sum_first"
    sumFirst :: <span class="hljs-type">ArrayArray</span># -&gt; <span class="hljs-type">IO</span> <span class="hljs-type">CInt</span>
</code></pre>
<h4>Wrap around IO monad.</h4>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">MIO</span> a = <span class="hljs-type">MIO</span> (<span class="hljs-type">IO</span> <span class="hljs-title">a</span>)</span>
</code></pre>
<p>It's ok to replace IO type with your customized IO newtype wrapper in a foreign import. GHC will recognize the wrapper IO and accept it as an IO monad.</p>
<p>This is acceptable even if there is no IO monad explicitly specified in the type signature.</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> <span class="hljs-string">"dynamic"</span>
    baz :: (<span class="hljs-type">Int</span> -&gt; <span class="hljs-type">MIO</span> <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">CInt</span> -&gt; <span class="hljs-type">MIO</span> <span class="hljs-type">Int</span>
</code></pre>
<p><code>MIO</code> limits IO actions can be performed by, prevents you from calling arbitrary IO actions.</p>
<h4>Explicit forall</h4>
<p>You can quantify type variables in foregin import with explicit forall.</p>
<pre><code class="language-haskell"><span class="hljs-meta">{-# LANGUAGE ExplicitForAll #-}</span>
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> <span class="hljs-keyword">ccall</span> <span class="hljs-string">"mmap"</span> cMmap :: forall a. <span class="hljs-type">CSize</span> -&gt; <span class="hljs-type">IO</span> (<span class="hljs-type">Ptr</span> a)
</code></pre>
<h4>Memory allocation</h4>
<p>FforFI library provides some functions to allocate memory explicitly. There are some differences between these meneory allocation methods.</p>
<h6><code>alloca</code></h6>
<p>Shor-term allocation. Internally it uses <code>MutableByteArray#</code>, so the allcation and deallocation are fast. It's faster then C's heap malloc/free, but slower than C's heap allocation. Because it has the lowest overheat, it's the best choice for most of the time. Ppl normally use it to marshaling data to and from FFI functions.</p>
<h6><code>mallocForeignPtr</code></h6>
<p>Long-term allocation that requires garbage collection. Internally using <code>MutableByteArray#</code>, so it's very similar to <code>alloca</code> but the memory is pointed by a <code>ForeignPtr</code>.</p>
<h6><code>Foreign.malloc / Foreign.free</code></h6>
<p>Simply a wrapper over c's <code>malloc/free</code>. It's much slower than other methods, so use it as the last resort.</p>
<h6><code>Foreign.Marshal.Pool</code></h6>
<p>A pool implemented with <code>malloc/free</code>.</p>
<h4>Pinned Byte Array</h4>
<p>If a byte array is pinned it cannot be moved by the garbage collector. The byte array has a stable address that can be safely requested with <code>byteArrayContents#</code>.</p>
<p>You can get a pinned byte array by allocating it with <code>newPinnedByteArray#</code>. Besides that, if the byte array is large (as large as 80% of a 4kb block) or if ithas been copied into a compact region, rts will pin it automatically.</p>
<h2>GHC extension for class and instances declaration</h2>
<p>When typeclass was first introduced it was considered an experimental feature of haskell, so initally it was added in a conservative manner. As time passed people realize there are a lot of space to extend the funtionality of typeclass, and these enhancements comes as language extension. The <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/1997/01/multi.pdf">paper</a> has a collections of examples for the rationale of different extensions.</p>
<h4>Inferred contexts</h4>
<h5>{-# LANGUAGE MultiParamTypeClasses #-}</h5>
<p>Literaly allows multiple parameters when declaring type classes. Some typeclass is define not only on one type, but on a tuple of types. By default haskell cannopt express this tupled type class. The most famous example is to define <code>StateMonad</code>.</p>
<pre><code class="language-haskell"><span class="hljs-meta">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">StateMonad</span> m s <span class="hljs-keyword">where</span></span>
    getS :: m s
    putS :: m -&gt; m ()
</code></pre>
<p>The state monad is actually defined in terms of two parameters, both the state it self and the value the state return.<br>
zz<br>
In concurrent haskell, you have funtions like this:</p>
<pre><code class="language-haskell"><span class="hljs-title">newMutVar</span> :: a -&gt; <span class="hljs-type">IO</span> (<span class="hljs-type">MutVar</span> a)
<span class="hljs-title">getMutVar</span>:: <span class="hljs-type">MutVar</span> -&gt; <span class="hljs-type">IO</span> a
<span class="hljs-title">putMutVar</span>:: <span class="hljs-type">MutVar</span> a -&gt; a -&gt; <span class="hljs-type">IO</span> ()
</code></pre>
<p>And for ST moand you have</p>
<pre><code class="language-haskell"><span class="hljs-title">newST</span> :: a -&gt; <span class="hljs-type">ST</span> s (<span class="hljs-type">MutVar</span> s a)
<span class="hljs-title">getST</span> :: <span class="hljs-type">MutVar</span> s a -&gt; <span class="hljs-type">ST</span> s a
<span class="hljs-title">putST</span> :: <span class="hljs-type">MutVar</span> s a -&gt; a -&gt; <span class="hljs-type">ST</span> s ()
</code></pre>
<p>There are some commonalities between these group of funtions. We cannot abstract the commonalities into a typeclass in default haskell, but with multi parameter typeclass we can write</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Monad</span> m -&gt; <span class="hljs-type">VarMonad</span> m v <span class="hljs-keyword">where</span></span>
    new :: a -&gt; m (v a)
    get :: v a -&gt; m a
    put :: v a -&gt; a -&gt; m ()
</code></pre>
<p>On extra benefit is that you can also add typeclass constraints for each parameters separately for any specific instance, which is not possible without multi parameter typeclass.</p>
<h5>{-# LANGUAGE FunctionalDependencies #-}</h5>
<p><code>a | a -&gt; b</code> reads as a uniquely determines b.</p>
<pre><code class="language-haskell"><span class="hljs-meta">{-# LANGUAGE FunctionalDependencies #-}</span>
<span class="hljs-meta">{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class="hljs-comment">-- type of c depends on the type of a and b</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Add</span> a b c | a b -&gt; c <span class="hljs-keyword">where</span></span>
  plus :: a -&gt; b -&gt; c

<span class="hljs-comment">-- This is correct</span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Add</span> <span class="hljs-type">Integer</span> <span class="hljs-type">Integer</span> <span class="hljs-type">Integer</span> <span class="hljs-keyword">where</span></span>
  plus x y = x + y

<span class="hljs-comment">-- This is a type error X</span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Add</span> <span class="hljs-type">Integer</span> <span class="hljs-type">Integer</span> <span class="hljs-type">Double</span> <span class="hljs-keyword">where</span></span>
  plus x y = fromIntegral x + fromIntegral y
</code></pre>
<h5>{-# LANGUAGE FlexibleContexts #-}</h5>
<p>Normally the assertions in the context of the instance declaration must be of the form <code>C a</code>.</p>
<p>With <code>flexible contexts</code>  this rule is relaxed to that an instance declaration can have</p>
<pre><code class="language-haskell"><span class="hljs-meta">{-# LANGUAGE FlexibleContexts #-}</span>

</code></pre>
<h5>{-# LANGUAGE InstanceSigs #-}</h5>
<h2>GHC Extensions for deriving</h2>
<p>Whether a type can derive a typeclass is somewhat unintuitive. The rule of thumbs, haskell take the most conservative dicision. If there is ambiguity about the deriving it will not be able to derive.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">T0</span> f a = <span class="hljs-type">MkT0</span> a <span class="hljs-keyword">deriving</span> <span class="hljs-type">Eq</span></span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">T1</span> f a = <span class="hljs-type">MkT1</span> (<span class="hljs-title">f</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">deriving</span> <span class="hljs-type">Eq</span></span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">T2</span> f a = <span class="hljs-type">MkT2</span> (<span class="hljs-title">f</span> (<span class="hljs-title">f</span> <span class="hljs-title">a</span>)) <span class="hljs-keyword">deriving</span> <span class="hljs-type">Eq</span></span>
</code></pre>
<p>First two cases are able to be derived directly. However, the third one can lead to unterminated instances, so by default Haskell rejects it.</p>
<h5>{-# LANGUAGE StandaloneDeriving #-}</h5>
<pre><code>{-# StandaloneDeriving #-}
data Foo a = Bar a | Baz String deriving instance Eq a => Eq (Foo a)
</code></pre>
<p>This extension allows you to derive a typeclass based on a specific typeclass instance.</p>
<h5>{-# GeneralizedNewtypeDeriving #-}</h5>
<h5>{-# LANGUAGE DerivingStrategies #-}</h5>
<h5>{-# LANGUAGE DerivingVia #-}</h5>
<h2>Conclusion</h2>
<p>To some extension GHC extension is haskell itself, so besides those core feataures like higher order function, higher kinded types, most of new developments are delivered in the form of language extensions. So far most materials I read merely introduce extensions, or just briefly mention stuffs like <code>OverloadedStrings</code>. After you finish those books and look into some real code bases, you get devastated by 20 languages extensions and bunch of imports in every files. I fill there is a descrepency between haskell teaching materials and how people really use haskell to write program.</p>
