<h1>Take some haskell notes</h1>
<h2>Monad Transformer</h2>
<p>How do you use several monads at once?</p>
<h2>Typeclass relationship</h2>
<p>This map is kinda cool so I put it here.</p>
<pre><code>        Haskell Typeclass relationships, definition and intuitions

     Functor   ~Apply...........Semigroup
       |                             |
       |                             |
   +---+-----+                       V
   |   |     |        ............Monoid ..Catgegory
   |   | .Applicative  .             .      |
   |   | .      |      .             .      |
   |   | .      +--------------+     .      |
   |   | .      |      .       |     .      |
   |   | .      |   ......     |     .......|....................
   |   | .      |   .    .     |     .      |                   .
~  V   | .      |   .    .     V     .      V                   .
Comonad| .      V   . Folable Monad...   Arrow+->ArrowZero->ArrowPlus
       | . Alternative |         |   .        |
       | .             |  +------+----------+ +--+----+
       | .             |  |      |   .      | |  |    |
       V .             |  V      V   .      | |  |    V
    Traversable  <------+ MonadMix MonadPlus| |  | ArrowLoop
                                            | |  |
                                            | |ArrowChoice
                                            | V
                                         ArrowApply
</code></pre>
<ul>
<li>Solid arrows point from the general to specific.</li>
<li>Dotted lines indicatte some other relationship.</li>
<li>Monad and ArrowApply are equivalent.</li>
<li>Apply and Comonad are greyed out since they are not actually in the standard hasekell libraries.</li>
</ul>
<h2>Data.Vector</h2>
<p>Vector is easier to ue than <code>array</code>, and is the most common array type in haskell. You see people use it all the time. There are twop flavours: mutable and immutable.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Vector</span> a</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">MVector</span> a</span>
</code></pre>
<p>Most list funcitons also work for vector. But there are some specific apis functions</p>
<pre><code class="language-haskell">
(!?) :: <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Maybe</span> a

<span class="hljs-comment">-- o(1) without boud checking.</span>
<span class="hljs-title">unsafeIndex</span> :: <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Int</span> -&gt; a
<span class="hljs-title">unsafeHead</span> :: <span class="hljs-type">Vector</span> a -&gt; a
<span class="hljs-title">unsafeTail</span> :: <span class="hljs-type">Vector</span> a -&gt; a

<span class="hljs-comment">-- monadic indexing</span>
<span class="hljs-title">indexM</span> :: <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Int</span> -&gt; m a
...

<span class="hljs-comment">-- slicing</span>
<span class="hljs-comment">-- O(1) slice without copying it.</span>
<span class="hljs-title">slice</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Vector</span> a
<span class="hljs-title">init</span> :: <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Vector</span> a
<span class="hljs-title">tail</span> :: <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Vector</span> a
<span class="hljs-title">take</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Vector</span> a
<span class="hljs-title">drop</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Vector</span> a
<span class="hljs-title">splitAt</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Vector</span> a -&gt; (<span class="hljs-type">Vector</span> a, <span class="hljs-type">Vector</span> a)
<span class="hljs-title">splitAt</span> n v = (take n v, drop n v)

<span class="hljs-comment">-- bulk updates. Update the index in [(Int a)]</span>
(//) :: <span class="hljs-type">Vector</span> a -&gt; [(<span class="hljs-type">Int</span> a)] -&gt; <span class="hljs-type">Vector</span> a

<span class="hljs-comment">-- mutable vectors</span>
<span class="hljs-title">freeze</span> :: <span class="hljs-type">PrimeMonad</span> m =&gt; <span class="hljs-type">MVector</span> (<span class="hljs-type">PrimeState</span> m) a -&gt; m (<span class="hljs-type">Vector</span> a)
<span class="hljs-title">thaw</span> :: <span class="hljs-type">PrimeMonad</span> m =&gt;  <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">MVector</span> (<span class="hljs-type">PrimeState</span> m) a
<span class="hljs-title">copy</span> :: <span class="hljs-type">PrimeMonad</span> m =&gt; <span class="hljs-type">MVector</span>  (<span class="hljs-type">PrimeState</span> m) a -&gt; vector a -&gt; m ()
</code></pre>
<h2>Data.Array</h2>
<p>Array are by default immutable boxed value. Boxed means data are just ordinary haskell value and are evaluated lazily. There are 9 types of array constructors exposed from <code>Data.Array</code>. Kinda bloated. Because of its rich features, it is a perfect opportunity for studying how haskell expressive various data structures.</p>
<pre><code>====================================================================
             Immutable          IO monad         ST monad
====================================================================
Standard       Array             IOArray          STArray
              DiffArray
====================================================================
Unboxed       UArray             IOUArray         STUArray
             DiffUArray         StorableArray
====================================================================
</code></pre>
<p>Some types and typeclass defined in <code>array</code></p>
<pre><code class="language-haskell"><span class="hljs-comment">-- i is the index type, e is the element type</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Array</span> i e</span>
<span class="hljs-comment">-- take index value pair in range of (i, i)</span>
<span class="hljs-title">array</span> :: <span class="hljs-type">Ix</span> i =&gt; (i, i) -&gt; [(i, e)] -&gt; <span class="hljs-type">Array</span> i e
<span class="hljs-comment">-- just take part of the list into an array.</span>
<span class="hljs-title">listArray</span> :: <span class="hljs-type">Ix</span> i =&gt; (i, i) -&gt; [e]  -&gt; <span class="hljs-type">Array</span> i e
</code></pre>
<h4>Baisc arrays</h4>
<p>The basical types are <code>Array</code>, <code>IOArray</code>, and <code>STArray</code>. They are boxed and have different immutabilities. Note that because if you don't have IO or ST everything is pure functions, so update (//) for Array is literally replace the old array with a new one, and compiler will not optmize that to a stateful operation. If you want to have a efficient update you can convert it to STArray for mutation and then convert it back to immutable.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- Immutable arrays</span>
<span class="hljs-keyword">import</span> Data.Array
<span class="hljs-keyword">import</span> Data.Array.ST
<span class="hljs-keyword">import</span> Data.Array.IO
<span class="hljs-keyword">import</span> Control.Monad.St

<span class="hljs-title">buildPair</span> :: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)
<span class="hljs-title">buildPair</span> = <span class="hljs-keyword">let</span> arr = listArray (<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) (repeat <span class="hljs-number">37</span>) :: <span class="hljs-type">Array</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>
                arr' = arr // [(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>)]
             <span class="hljs-keyword">in</span> (arr ! <span class="hljs-number">1</span>, arr' ! <span class="hljs-number">1</span>)

<span class="hljs-comment">-- Mutable IO arrays</span>
<span class="hljs-comment">-- It's similar to IORefs but contains multiple values.</span>
<span class="hljs-comment">-- Because `newArray` is overloaded, you need to annotate it.</span>
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    arr &lt;- newArray (<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) <span class="hljs-number">37</span> :: <span class="hljs-type">IO</span> (<span class="hljs-type">IOArray</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>)
    a &lt;- readArray arr <span class="hljs-number">1</span>
    write arr <span class="hljs-number">1</span> <span class="hljs-number">64</span>
    b &lt;- readArray arr <span class="hljs-number">1</span>
    print (a, b)

<span class="hljs-comment">-- Like how IORef is related to STRef, STArray is a more generic</span>
<span class="hljs-comment">-- version of IOArray.</span>
<span class="hljs-title">stArray</span> = newArray (<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) <span class="hljs-number">37</span> :: <span class="hljs-type">ST</span> s (<span class="hljs-type">STArray</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>)

<span class="hljs-comment">-- Freezing and thawing</span>
<span class="hljs-title">modifyAsST</span> :: <span class="hljs-type">Array</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Array</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>
<span class="hljs-title">modifyAsST</span> arr = runST $ <span class="hljs-keyword">do</span>
    starr &lt;- thaw arr
    writeArray arr <span class="hljs-number">1</span> <span class="hljs-number">64</span>
    newarr &lt;- freeze starr
    return newarr
</code></pre>
<h4>Diff arrays</h4>
<p>Updating an <code>Array</code> will just create a new copy of if, while using an <code>IOArray</code> or a <code>STArray</code> requires monadic code. <code>DiffArray</code> helps provide pure interface with efficient mutation uderneath.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- an example of using diff array. It forces evaluating element</span>
<span class="hljs-comment">-- a and b before the update.</span>
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">let</span> arr = listArray (<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>) [<span class="hljs-number">1.</span><span class="hljs-number">.1000</span>] :: <span class="hljs-type">DiffArray</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>
        a = arr ! <span class="hljs-number">1</span>
        b = arr ! <span class="hljs-number">2</span>
        arr2 = a `seq` b `seq` (arr // [(<span class="hljs-number">1</span>, <span class="hljs-number">37</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">64</span>)])
    print (a, b, c)
</code></pre>
<h4>Unboxed arrays</h4>
<p>Most implementations of lazy evaluation usually will have value being represented as pointers to either the value itself, or code for computing the value. This is an extra indirection that requires an extra tag at the runtime. The indirection is called <code>box</code>. Like <code>box</code> in rust refer to a pointer to some memory on the heap, and <code>box</code> in other VM languages generally means a object. Boxed value are easy to manage, but the extra taggin information can make it inefficient in many cases (like an array...)</p>
<p>Unboxed arrays have the same api, it's just their elements are evaluated eagerly without involvement of lazyniess.</p>
<h4>Storable arrays</h4>
<p><code>IOUArray</code> serve the purpose of mutable unboxed array, but it is not transferable to foreign routines, for instance, turn into C array. For this purpose you can use <code>StorableArray</code> which is also mutable but will be allocated non-relocatable ghc heap. Doing so allows it has a fixed address and C routine and use it to find the array.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- this enable c extensions</span>
<span class="hljs-meta">{-# OPTIONS_GHC -fglasgow-exts #-}</span>
<span class="hljs-keyword">import</span> Data.Array.Storable
<span class="hljs-keyword">import</span> Foreign.Ptr
<span class="hljs-keyword">import</span> Foreign.C.Types

<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    arr &lt;- newArray (<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) <span class="hljs-number">37</span> :: <span class="hljs-type">IO</span> (<span class="hljs-type">StorableArray</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>)
    withStorableArray arr
        (\ptr -&gt; memset ptr <span class="hljs-number">0</span> <span class="hljs-number">40</span>)
    b &lt;- readArray arr <span class="hljs-number">1</span>
    print (a, b)

<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> call <span class="hljs-keyword">unsafe</span> <span class="hljs-string">"string.h"</span>
    memset :: <span class="hljs-type">Ptr</span> a -&gt; <span class="hljs-type">CInt</span> -&gt; <span class="hljs-type">CSize</span> -&gt; <span class="hljs-type">IO</span> ()
</code></pre>
<h4>Unsafe operations</h4>
<p><code>freeze/thaw</code> copy the entire array when doing the conversion. If you are sure the mutable array will not be modified after it is turned into immutable array, or an immutable array will not be used after it is turned into mutable, you can use <code>unsafeFreeze/unsafeThaw</code> which do inplace replacement.</p>
<h4>Unsafe operations and thread safe</h4>
<p><code>unsafe*</code> operations in general modifies memory, and they should not be used with multi-threaded access to the array.</p>
<h4>Conclusion</h4>
<p>Array interface resembles a lot to many other data  structures in haskell. For instance, List and ByteString. A haskell library can have these notion of <code>safe</code> and <code>unsafe</code>, <code>immutable</code> and <code>IO/ST</code>, <code>strict</code> and <code>lazy</code> (<code>Boxed</code> and  <code>Unboxed</code>) etc., and this is something not very common in other languages.</p>
<p>Different versions of apis arranged in different modules of the package, so if you want to use multiple of them you need to import themfrom their specific module. This is why the first screen of a haskell program is usually filled with imports.</p>
