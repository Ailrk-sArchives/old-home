<h1>Take some haskell notes</h1>
<h2>Monad Transformer</h2>
<p>How do you use several monads at once?</p>
<h4>Stack one monad to another</h4>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">MaybeT</span> m a = <span class="hljs-type">MaybeT</span> { <span class="hljs-title">runMaybeT</span> :: <span class="hljs-title">m</span> (<span class="hljs-type">Maybe</span> <span class="hljs-title">a</span>)}</span>
</code></pre>
<p><code>m</code> is an action, call <code>runMaybeT</code> will pull out the action get a monadic value that return <code>Maybe a</code></p>
<h4>Define some typeclasses for <code>MaybeT</code></h4>
<p>Monad transformer generally should have the same typeclass implemented as the type they wrap. It makes more sense for <code>MaybeT</code> to behave like a <code>Maybe</code> except the ability of carrying IO action.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- the bind part is exactly the same as Maybe</span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">Monad</span> (<span class="hljs-type">MaybeT</span> <span class="hljs-title">m</span>) <span class="hljs-keyword">where</span></span>
    return = <span class="hljs-type">MaybeT</span> . return .return
    x &gt;&gt;= f = <span class="hljs-type">MaybeT</span> $ <span class="hljs-keyword">do</span>
        maybeval &lt;- runMaybeT x
        <span class="hljs-keyword">case</span> maybeval <span class="hljs-keyword">of</span>
            <span class="hljs-type">Nothing</span> -&gt; return <span class="hljs-type">Nothing</span>
            <span class="hljs-type">Just</span> val -&gt; runMaybeT $ f val
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">Applicative</span> (<span class="hljs-type">MaybeT</span> <span class="hljs-title">m</span>) <span class="hljs-keyword">where</span></span>
    pure = return
    (&lt;*&gt;) = ap
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">Functor</span> (<span class="hljs-type">MaybeT</span> <span class="hljs-title">m</span>) <span class="hljs-keyword">where</span></span>
    fmap = liftM
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">Alternative</span> (<span class="hljs-type">MaybeT</span> <span class="hljs-title">m</span>) <span class="hljs-keyword">where</span></span>
    empty = <span class="hljs-type">MaybeT</span> $ return <span class="hljs-type">Nothing</span>
    x &lt;|&gt; y = <span class="hljs-type">MaybeT</span> $ <span class="hljs-keyword">do</span>
        maybeval &lt;- runMaybeT x
        <span class="hljs-keyword">case</span> maybeval <span class="hljs-keyword">of</span>
            <span class="hljs-type">Nothing</span> -&gt; runMaybeT y
            <span class="hljs-type">Just</span> _ -&gt; return maybeval
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">MonadPlus</span> (<span class="hljs-type">MaybeT</span> <span class="hljs-title">m</span>) <span class="hljs-keyword">where</span></span>
    mzero = empty
    mplus = (&lt;|&gt;)
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">MonadTrans</span> <span class="hljs-type">MaybeT</span> <span class="hljs-keyword">where</span></span>
    lift = <span class="hljs-type">MaybeT</span> . (liftM <span class="hljs-type">Just</span>)
</code></pre>
<p><code>liftM :: Monad m =&gt; (a -&gt; b) -&gt; m a -&gt; m b</code> is the monad version of <code>fmap</code>. (<code>liftM</code> exist because monads are not automatically functors in haskell).</p>
<h4>MonadTrans and lift</h4>
<p>The key util for using monad transformer is <code>lift :: (MonadTrans t, Monad m) =&gt; m a -&gt; t m a</code>, it lifts the <code>m a</code> into the monad transformer <code>t</code>. <code>m a</code> is an action, so it can do all different stuffs. For instance <code>putStrLn &quot;haha&quot; :: IO ()</code> can be the <code>m a</code> part, and <code>do $ lift putStrLn</code> in <code>MaybeT</code> context will lift <code>Maybe</code> into the <code>IO</code> monad, and get <code>MaybeT $ IO (Maybe ())</code>, which is how we define the <code>MaybeT</code>.</p>
<p>The function is called <code>lift</code>, but actually it get the inner value by shove into the transformer type.</p>
<pre><code class="language-haskell"><span class="hljs-title">foo</span> :: <span class="hljs-type">StateT</span> s <span class="hljs-type">IO</span> <span class="hljs-type">String</span>
<span class="hljs-title">foo</span> = <span class="hljs-keyword">do</span>
  s &lt;- lift $ getLine
  return s
</code></pre>
<p><code>getLine :: IO String</code> turned into <code>StateT s IO String</code>, so the value <code>String</code> can be shoved in.</p>
<p>Note <code>StateT s IO String = { runStateT :: s -&gt; IO (String, s)}</code></p>
<p>Note <code>MaybeT IO String = { runMaybeT :: IO (Maybe String) }</code></p>
<p>Conventinally the last value of a monad the the value</p>
<h4>Define some other transformers</h4>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">ListT</span> m a :: { <span class="hljs-title">runListT</span> :: <span class="hljs-title">m</span> [<span class="hljs-title">a</span>] }</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">ExceptT</span> e m a :: { <span class="hljs-title">runExceptT</span> :: <span class="hljs-title">m</span> (<span class="hljs-type">Either</span> <span class="hljs-title">e</span> <span class="hljs-title">a</span>) }</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">WriterT</span> m a :: { <span class="hljs-title">runWriterT</span> :: <span class="hljs-title">m</span> (<span class="hljs-title">a</span>, <span class="hljs-title">w</span>) }</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">ReaderT</span> m a :: { <span class="hljs-title">runReaderT</span> :: <span class="hljs-title">r</span> -&gt; <span class="hljs-title">m</span> <span class="hljs-title">a</span> }</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">StateT</span> m a :: { <span class="hljs-title">runStateT</span> :: <span class="hljs-title">s</span> -&gt; <span class="hljs-title">m</span> (<span class="hljs-title">a</span>, <span class="hljs-title">s</span>) }</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">ContT</span> n a :: { <span class="hljs-title">runContT</span> :: (<span class="hljs-title">a</span> -&gt; <span class="hljs-title">m</span> <span class="hljs-title">r</span>) -&gt; <span class="hljs-title">m</span> <span class="hljs-title">r</span>}</span>
</code></pre>
<p>Note <code>ContT</code> is different because a continuation has the same type for it's result type and the second argument. But for all other types above they just follows the normal rule: wrap the inner monad inside <code>m</code>. How to defie a monad transformer is an ad hoc process, and there is no general formula for automatically generating monad transformers.</p>
<h4>MonadState that you might use regularly</h4>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> (<span class="hljs-type">Monad</span> <span class="hljs-title">m</span>) =&gt; <span class="hljs-type">MonadState</span> s (<span class="hljs-type">StateT</span> <span class="hljs-title">s</span> <span class="hljs-title">m</span>) <span class="hljs-keyword">where</span></span>
    get = <span class="hljs-type">StateT</span> $ \s -&gt; return (s, s)
    put s = <span class="hljs-type">StateT</span> $ \_ -&gt; return ((), s)
</code></pre>
<p>Useful <code>MonadPlus</code> instance that allows the underlying state monad get combined</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> (<span class="hljs-type">MonadPlus</span> <span class="hljs-title">m</span>) =&gt; <span class="hljs-type">MonadPlus</span> (<span class="hljs-type">StateT</span> <span class="hljs-title">s</span> <span class="hljs-title">m</span>) <span class="hljs-keyword">where</span></span>
    mzero = <span class="hljs-type">StateT</span> $ \_ -&gt; zero
    (<span class="hljs-type">StateT</span> x1) `mplus` (<span class="hljs-type">StateT</span> x2) =
        <span class="hljs-type">StateT</span> $ \s -&gt; (x1 s) `mplus` (x2 s)
</code></pre>
<h4>Some thoughts</h4>
<p>if a type is <code>newtype SomeType m a = SomeType {runSomeType :: m a} </code>, context of do do notation in <code>SomeType $ do</code> will be m, so you can <code>a &lt;- x :: (m a)</code> there. Similarly, if you have a value<code>x :: SomeType m a</code> available in the do notation, you can pull out the <code>m a</code> part by doing <code>runSomeType x</code>. Sometimes some type seems get pulled out multiple times but nobody seems point out there is any potential performance issue. (maybe there is not because GHC can see the duplication in desugared <code>Core</code> language form and it can optmize it out?)</p>
<h2>Typeclass relationship</h2>
<p>This map is kinda cool so I put it here.</p>
<pre><code>        Haskell Typeclass relationships, definition and intuitions

     Functor   ~Apply...........Semigroup
       |                             |
       |                             |
   +---+-----+                       V
   |   |     |        ............Monoid ..Catgegory
   |   | .Applicative  .             .      |
   |   | .      |      .             .      |
   |   | .      +--------------+     .      |
   |   | .      |      .       |     .      |
   |   | .      |   ......     |     .......|....................
   |   | .      |   .    .     |     .      |                   .
~  V   | .      |   .    .     V     .      V                   .
Comonad| .      V   . Folable Monad...   Arrow+->ArrowZero->ArrowPlus
       | . Alternative |         |   .        |
       | .             |  +------+----------+ +--+----+
       | .             |  |      |   .      | |  |    |
       V .             |  V      V   .      | |  |    V
    Traversable  <------+ MonadMix MonadPlus| |  | ArrowLoop
                                            | |  |
                                            | |ArrowChoice
                                            | V
                                         ArrowApply
</code></pre>
<ul>
<li>Solid arrows point from the general to specific.</li>
<li>Dotted lines indicatte some other relationship.</li>
<li>Monad and ArrowApply are equivalent.</li>
<li>Apply and Comonad are greyed out since they are not actually in the standard hasekell libraries.</li>
</ul>
<h2>Data.Vector</h2>
<p>Vector is easier to use than <code>array</code>, and is the most common array type in haskell; you see people use it all the time. There are twop flavours: mutable and immutable.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Vector</span> a</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">MVector</span> a</span>
</code></pre>
<p>Most list funcitons also work for vector. But there are some specific funcitons.</p>
<pre><code class="language-haskell">
(!?) :: <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Maybe</span> a

<span class="hljs-comment">-- o(1) without boud checking.</span>
<span class="hljs-title">unsafeIndex</span> :: <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Int</span> -&gt; a
<span class="hljs-title">unsafeHead</span> :: <span class="hljs-type">Vector</span> a -&gt; a
<span class="hljs-title">unsafeTail</span> :: <span class="hljs-type">Vector</span> a -&gt; a

<span class="hljs-comment">-- monadic indexing</span>
<span class="hljs-title">indexM</span> :: <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Int</span> -&gt; m a
...

<span class="hljs-comment">-- slicing</span>
<span class="hljs-comment">-- O(1) slice without copying it.</span>
<span class="hljs-title">slice</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Vector</span> a
<span class="hljs-title">init</span> :: <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Vector</span> a
<span class="hljs-title">tail</span> :: <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Vector</span> a
<span class="hljs-title">take</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Vector</span> a
<span class="hljs-title">drop</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">Vector</span> a
<span class="hljs-title">splitAt</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Vector</span> a -&gt; (<span class="hljs-type">Vector</span> a, <span class="hljs-type">Vector</span> a)
<span class="hljs-title">splitAt</span> n v = (take n v, drop n v)

<span class="hljs-comment">-- bulk updates. Update the index in [(Int a)]</span>
(//) :: <span class="hljs-type">Vector</span> a -&gt; [(<span class="hljs-type">Int</span> a)] -&gt; <span class="hljs-type">Vector</span> a

<span class="hljs-comment">-- mutable vectors</span>
<span class="hljs-title">freeze</span> :: <span class="hljs-type">PrimeMonad</span> m =&gt; <span class="hljs-type">MVector</span> (<span class="hljs-type">PrimeState</span> m) a -&gt; m (<span class="hljs-type">Vector</span> a)
<span class="hljs-title">thaw</span> :: <span class="hljs-type">PrimeMonad</span> m =&gt;  <span class="hljs-type">Vector</span> a -&gt; <span class="hljs-type">MVector</span> (<span class="hljs-type">PrimeState</span> m) a
<span class="hljs-title">copy</span> :: <span class="hljs-type">PrimeMonad</span> m =&gt; <span class="hljs-type">MVector</span>  (<span class="hljs-type">PrimeState</span> m) a -&gt; vector a -&gt; m ()
</code></pre>
<h2>Data.Array</h2>
<p>Array are by default immutable boxed value. Boxed means data are just ordinary haskell value and are evaluated lazily. There are 9 types of array constructors exposed from <code>Data.Array</code> you can choose from. Because of its rich features, it is a perfect opportunity to study how haskell express various data structures.</p>
<pre><code>====================================================================
             Immutable          IO monad         ST monad
====================================================================
Standard       Array             IOArray          STArray
              DiffArray
====================================================================
Unboxed       UArray             IOUArray         STUArray
             DiffUArray         StorableArray
====================================================================
</code></pre>
<pre><code class="language-haskell"><span class="hljs-comment">-- i is the index type, e is the element type</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Array</span> i e</span>
<span class="hljs-comment">-- take index value pair in range of (i, i)</span>
<span class="hljs-title">array</span> :: <span class="hljs-type">Ix</span> i =&gt; (i, i) -&gt; [(i, e)] -&gt; <span class="hljs-type">Array</span> i e
<span class="hljs-comment">-- just take part of the list into an array.</span>
<span class="hljs-title">listArray</span> :: <span class="hljs-type">Ix</span> i =&gt; (i, i) -&gt; [e]  -&gt; <span class="hljs-type">Array</span> i e
</code></pre>
<h4>Baisc arrays</h4>
<p>The basical types are <code>Array</code>, <code>IOArray</code>, and <code>STArray</code>. They are boxed and have different immutabilities. Note that because if you don't have IO or ST everything is pure functions, so update (//) for Array is literally replace the old array with a new one, and compiler will not optmize that to a stateful operation. If you want to have a efficient update you can convert it to STArray for mutation and then convert it back to immutable.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- Immutable arrays</span>
<span class="hljs-keyword">import</span> Data.Array
<span class="hljs-keyword">import</span> Data.Array.ST
<span class="hljs-keyword">import</span> Data.Array.IO
<span class="hljs-keyword">import</span> Control.Monad.St

<span class="hljs-title">buildPair</span> :: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)
<span class="hljs-title">buildPair</span> = <span class="hljs-keyword">let</span> arr = listArray (<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) (repeat <span class="hljs-number">37</span>) :: <span class="hljs-type">Array</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>
                arr' = arr // [(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>)]
             <span class="hljs-keyword">in</span> (arr ! <span class="hljs-number">1</span>, arr' ! <span class="hljs-number">1</span>)

<span class="hljs-comment">-- Mutable IO arrays</span>
<span class="hljs-comment">-- It's similar to IORefs but contains multiple values.</span>
<span class="hljs-comment">-- Because `newArray` is overloaded, you need to annotate it.</span>
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    arr &lt;- newArray (<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) <span class="hljs-number">37</span> :: <span class="hljs-type">IO</span> (<span class="hljs-type">IOArray</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>)
    a &lt;- readArray arr <span class="hljs-number">1</span>
    write arr <span class="hljs-number">1</span> <span class="hljs-number">64</span>
    b &lt;- readArray arr <span class="hljs-number">1</span>
    print (a, b)

<span class="hljs-comment">-- Like how IORef is related to STRef, STArray is a more generic</span>
<span class="hljs-comment">-- version of IOArray.</span>
<span class="hljs-title">stArray</span> = newArray (<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) <span class="hljs-number">37</span> :: <span class="hljs-type">ST</span> s (<span class="hljs-type">STArray</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>)

<span class="hljs-comment">-- Freezing and thawing</span>
<span class="hljs-title">modifyAsST</span> :: <span class="hljs-type">Array</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Array</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>
<span class="hljs-title">modifyAsST</span> arr = runST $ <span class="hljs-keyword">do</span>
    starr &lt;- thaw arr
    writeArray arr <span class="hljs-number">1</span> <span class="hljs-number">64</span>
    newarr &lt;- freeze starr
    return newarr
</code></pre>
<h4>Diff arrays</h4>
<p>Updating an <code>Array</code> will just create a new copy of it, but using an <code>IOArray</code> or a <code>STArray</code> requires monadic code. <code>DiffArray</code> helps provide pure interface with efficient mutation uderneath. Internally the update is performed in <code>IOArray</code>, but the interface get exposed is similar to <code>Array</code>.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- an example of using diff array. It forces evaluating element</span>
<span class="hljs-comment">-- a and b before the update.</span>
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">let</span> arr = listArray (<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>) [<span class="hljs-number">1.</span><span class="hljs-number">.1000</span>] :: <span class="hljs-type">DiffArray</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>
        a = arr ! <span class="hljs-number">1</span>
        b = arr ! <span class="hljs-number">2</span>
        arr2 = a `seq` b `seq` (arr // [(<span class="hljs-number">1</span>, <span class="hljs-number">37</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">64</span>)])
    print (a, b, c)
</code></pre>
<h4>Unboxed arrays</h4>
<p>Most implementations of lazy evaluation usually will have value being represented as pointers to either the value itself, or code for computing the value. This is an extra indirection that requires an extra tag at the runtime. The indirection is called <code>box</code>. Like <code>box</code> in rust refer to a pointer to some memory on the heap, and <code>box</code> in other VM languages generally means an object. Boxed value are easy to manage, but the extra taggin information can make it inefficient in many cases (like an array...)</p>
<p>Unboxed arrays have the same api, but their elements are evaluated eagerly.</p>
<h4>Storable arrays</h4>
<p><code>IOUArray</code> serve the purpose of mutable unboxed array, but it is not transferable to foreign routines, for instance, turn into C array. For this purpose you can use <code>StorableArray</code> which is also mutable but will be allocated non-relocatable ghc heap. Doing so allows it has a fixed address and C routine and use it to find the array.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- this enable c extensions</span>
<span class="hljs-meta">{-# OPTIONS_GHC -fglasgow-exts #-}</span>
<span class="hljs-keyword">import</span> Data.Array.Storable
<span class="hljs-keyword">import</span> Foreign.Ptr
<span class="hljs-keyword">import</span> Foreign.C.Types

<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    arr &lt;- newArray (<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) <span class="hljs-number">37</span> :: <span class="hljs-type">IO</span> (<span class="hljs-type">StorableArray</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>)
    withStorableArray arr
        (\ptr -&gt; memset ptr <span class="hljs-number">0</span> <span class="hljs-number">40</span>)
    b &lt;- readArray arr <span class="hljs-number">1</span>
    print (a, b)

<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> call <span class="hljs-keyword">unsafe</span> <span class="hljs-string">"string.h"</span>
    memset :: <span class="hljs-type">Ptr</span> a -&gt; <span class="hljs-type">CInt</span> -&gt; <span class="hljs-type">CSize</span> -&gt; <span class="hljs-type">IO</span> ()
</code></pre>
<h4>Unsafe operations</h4>
<p><code>freeze/thaw</code> copy the entire array when doing the conversion. If you are sure the mutable array will not be modified after it is turned into immutable array, or an immutable array will not be used after it is turned into mutable, you can use <code>unsafeFreeze/unsafeThaw</code> which do inplace replacement.</p>
<h4>Unsafe operations and thread safe</h4>
<p><code>unsafe*</code> operations in general modifies memory, and they should not be used with multi-threaded access to the array.</p>
<h4>Conclusion</h4>
<p>Array interface shows some characteristics common to many other haskell libraries. For instance, List and ByteString. A haskell library can have these notions of <code>safe</code> and <code>unsafe</code>, <code>immutable</code> and <code>IO/ST</code>, <code>strict</code> and <code>lazy</code> (<code>Boxed</code> and  <code>Unboxed</code>) etc. Choose the correct one to use is kinda important for writing ok ok code.</p>
<p>Different flavors of apis arranged in different modules, so if you want to use bunch of them you need to import each one from their specific modules. This is why the first screen of a haskell program is usually filled with imports.</p>
<h2>Generational garbage collector</h2>
<p>Normaly you would have only one heap, but it will takes forever to mark and sweep and compact everything. So instead you make a small heap and a large heap, the large heap is much bigger than the small heap.</p>
<p>For a garbage collector language, every objects consists of data and pointers, and the garbage collector knows which parts are the pointers. Actually the pointers point to a table of pointers whose entries are the real pointers. This design allows an object to be moved with only one real pointer being updated. With the two heap design, pointers either go to the small heap or the large heap.</p>
<p>For generational garbage collection, all new objects are allocated in the small heap. If the small heap is full, map-and-sweep will try to free some space in it. This freeing process happen frequently, and for objects who survived for a gc will be moved to the large heap. In case of after moving objects into the large heap still doesn't make enough space for the small heap, objects will just be allocated freely inthe large heap. If even the large heap is full, both heap needs to be swept.</p>
<p>For most of the time only the small heap will be swept, which can drastically decrease the gc time.</p>
<h4>Benefits of immutable objects on garbage collection</h4>
<p>Immutable objects has many garantees we can make when doing garbage collection. First of all there will be no circular refernce for immutable objects, and you don't need to worry about modification under the gc's nose because the object has mutable structure including reference counts. More information <a href="https://wiki.c2.com/?ImmutableObjectsAndGarbageCollection#:~:text=The%20trick%20is%20that%20immutable,key%20property%20of%20immutable%20data.">here</a></p>
<p>For immutable objects it's impossible to have a pointer from an older generation to a newer generation. It's because the newer generation value doesn't exist when the older value is created, and since the value is immutable after the older value is moved into the large heap it's pointer will not point to anything else newly created in the small heap.</p>
<h2>Some GHC Heap and garbage collector</h2>
<h4>GHC gc</h4>
<p>GHC gc is a generational garbage collector with two garbage collection strategies. Namely</p>
<ul>
<li>Copy Collection</li>
<li>Mark-Sweep Compact collection</li>
</ul>
<p>Most programs run under copy collector until the memory usage has reached a threashold (like 30% of the allowed heap size). At that point GHC gc will do a mark-and-sweep.</p>
<p>Haskell produce much more memory garbage then traditional programs because of it's immutability. Since you cannot mutate date inplace, the only way to store result of the next operation is to create a new value. The weird thing is this doesn't cause any problem because of the immutability.</p>
<h6>Gain from immutability</h6>
<p>GHC uses generational garbage collector. Everytime a new data is created it will be allocated in the small heap. And whenever it is used out, a minor gc will happen, the gc will scan the small heap and free unused value. Another way to look at it is the gc pick alive values and copy them into the large heap, and all the data left in small heap are garbage. This implies that the fewer values survive the gc the faster the garbage collection will be. Since immutable data never points to the small heap, we only need to pick those data newly survived, and the rest of data must be unused and safe to be freed.</p>
<h5>STRef/IORef break the niceness</h5>
<p>All the good things with immutability break with boxed mutable reference, because now you have values in the large heap that might points to the small heap. In haskell you can have mutable data with <code>STRef</code> or <code>IORef</code> and <code>STArray</code> and <code>IOArray</code>. To solve this problem, for every single gc each element in mutatble data structures should be scanned.</p>
<h5>Performance implication</h5>
<p>Because we need to check the mutable data, gc times will be bad for programs with lots of <code>IORef</code> and <code>STRef</code>. To solve this problem one can add ghc option like <code>+RTSE- A10m</code> to increase the size of the small heap to 10mb (Make minor gc less frequent). // see the effect with <code>+RTS -sstderr</code> option.</p>
<h4>GHC heap, Array#, MutableArray#, ByteArray#, MutableByteArray#, pinned and moveable byte arrays.</h4>
<p>GHC heap contains two types of objects. There are objects that are just byte sequences, and others are boxed values. <code>Array#</code> is a type used by GHC internally to represents a sequence of boxes. An operation  in ST monad there is an operation with type like <code>Int -&gt; ST s Array#</code> allocates array of specified size in heap. The <code>Array#</code> type is used to represent boxed immutable arrays in <code>Array</code> directly.</p>
<p>In the case of mutable boxed arrays like <code>IOArray/STArray</code>, there is an internal type <code>MutableArray#</code>. The reason why these type exist is because GHC has 2-stage garbage collection mechanism. The internal representation of <code>Array#</code> and <code>MutableArray#</code> is the same, allows <code>unsafeFreeze/unsafeThaw</code> do a inplace conversion.</p>
<p>Unboxed arrays are represented by <code>ByteArray#</code> type.</p>
