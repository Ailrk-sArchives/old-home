<h1>GraphQL, oauth2, node, all web stuffs.</h1>
<p>Some graphql, oauth2 to prepare for making canvas bot.</p>
<h2>GraphQL</h2>
<p>Replcement for RESTful apis. It's a query language with a sound type system for APIs and a server side runtime to exeucting the query. It's a facade design and can be added to existed code and data.</p>
<p>GraphQL modeling data with graph, you might try some well known technics like zipper to work with it.</p>
<h4>Process</h4>
<p>You model your data with a &quot;type system&quot;. (I feel they just want to use this word) and define some functions for every single fields</p>
<pre><code>type Query {
    me: User
}
type User {
    id: ID
    name: String
}
functions Query_me(request) { return request.auth.user; }
</code></pre>
<p>And when the graphsQL server is running, query works like this:</p>
<pre><code>{ me { name } } ->  { "me": { "name": "Luke Skywalker"}}
</code></pre>
<h4>How to use</h4>
<p>The whole design is like a weirdly typed quasi quotes for describing json. You have some short hand to work with the tree easier, by largely it's just a mega tempalte string. I can imagine support this in typescript directly via bable transform.</p>
<h5>Fields</h5>
<p>Note Your query has exactly the same shape as your result.</p>
<p>Note Data returned can be nested elements like another object.</p>
<pre><code>{ hero {name} } -> { "data": { "hero": { "name": "R2-D2" } } }
</code></pre>
<h5>Arugments</h5>
<p>Each fileds can be passed with an argument for filtering. The following example with query for the specific human with id &quot;1000&quot;.</p>
<pre><code>{
    human(id: "1000") {
        name
        height
    }
}
</code></pre>
<h5>Alias</h5>
<p>You can make new alias of the same field</p>
<pre><code>{
    empireHero: hero(episode: EMPIRE) { name }
    jediHero: hero(episode: JEDI) { name }
}
</code></pre>
<h5>Fragments</h5>
<p>Alias for a sub tree. It works like quasi quotes you can replace text inside.</p>
<pre><code>query com($first: int = 3) {
    com1: hero(episode: EMPIRE) { ...comparisionField }
    com2: hero(episode: JEDI) { ...comparisionField }
}
fragment comparisionField on Character {
    name
    friendConnection(first: $first) {
        totalCount
        edges {
            node {
                name
            }
        }
    }
}
</code></pre>
<h5>Derectives</h5>
<p>Some macro for conditional querying. You have <code>@include(if: Boolean)</code> and <code>@skip(if: Boolean)</code> as builtin which are exactly the negation of each other.</p>
<pre><code>query Hero($episode: Episode, $withFriends: Boolean!) {
    hero(episode: $episode) {
        name
        friends @include(if: $withFriends) {
            name
        }
    }
}
</code></pre>
<p>Result</p>
<pre><code>{
    "data": {
        "hero" : { "name" : "R2-D2" }
    }
}
</code></pre>
<h5>Mutations</h5>
<p>Use mutation request to mutate value on the server side.</p>
<pre><code>mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {
  createReview(episode: $ep, review: $review) {
    stars
    commentary
  }
}
</code></pre>
<p>The data writes into the quasi quote will get transferred and recorded on the server side.</p>
<h4>GraphQL arch design: Single source of truth</h4>
<p>Everything pass through the same validation, authorization and error handling rules.</p>
<pre><code>-------------------------------------
    REST    GraphQL    RPC
-------------------------------------
         Authorization
        Business Logic Layer
-------------------------------------
         Persistence Layer
-------------------------------------
</code></pre>
