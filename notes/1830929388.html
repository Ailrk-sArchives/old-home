<h1>Haskell. mtl, some lense, some concurrency</h1>
<h2>MTL</h2>
<p>A library helps to use monad transformer easier.</p>
<h4>Review some monad transformer</h4>
<p>You want monad transformer to stack a monad on top of another, and lift the outer monad action into the transformer with function <code>lift :: (Monad m, MonadTrans t) =&gt; m a -&gt; t m a</code>.</p>
<p>Why this is useful? Imagine you have a maybe monad transformer <code>MaybeT IO a</code>, essentially what you are saying is you have a value <code>IO (Maybe a)</code>, and depends on how you define the monad instance it's bind probably be very similar to the primitive <code>Maybe</code>. But what if now you want to perform an <code>IO</code> action on this monad? You can do <code>lift putStrLn</code> which lift <code>putStrLn :: IO ()</code> into <code>MaybeT IO ()</code>.</p>
<p>This is a very generic concept and can be used to stack arbitrary monads. For instance, you have state monad transformer <code>newtype StateT s m a = StateT { runStateT :: \s -&gt; m (a, s)}</code>; writerT <code>newtype WriterT w m a = WriterT { runWriterT :: \w -&gt; m (a, w)}</code>; readerT <code>newtype ReaderT r m a = ReaderT { runReaderT :: r -&gt; m a}</code> and so on. The way to use them is similar. To use the original state or reader you just use the monad instance for the transformer. To use the wrapper monad <code>m</code>, you lift the action into the transformer.</p>
<p>You can tell the monad transformer is also a monad, so you can stick another layer of monad transformer on top of that, and make super complicated monad transformer.</p>
<p>Problem occurs when you have too many monads stacked together. To lift a specific monad action you might need multiple lift, like <code>lift . lift . lift action</code>, or if you want to return some stuufs you need <code>return .return . return</code>. This problem is already very obvious when I was doing the maybe monad exercise, and it could only be worse when the monad transformer get bigger and bigger.</p>
<h4>Some monad transformer laws</h4>
<p>Some invariants you can expect when using monad transformer.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- Law1</span>
<span class="hljs-title">lift</span> . return = return

<span class="hljs-comment">-- Law2</span>
<span class="hljs-title">lift</span> (m &gt;&gt;= f) = lift m &gt;&gt;= (lift . f)
</code></pre>
<p>Note a monad transformer tranform monad to monad. If we write down the kind we have</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- A monad</span>
<span class="hljs-type">Monad</span> (m :: * -&gt; *)

<span class="hljs-comment">-- A monad transformer tranfer monad to monad</span>
<span class="hljs-type">MonadTrans</span> (t :: (* -&gt; *) -&gt; * -&gt; *)
</code></pre>
<p>Note A monad transformer composes outside in but unrolls inside out.</p>
<h4>Some example with monad transformer</h4>
<p>Make a composite computation with both <code>Reader</code> and <code>Maybe</code> monad.</p>
<pre><code class="language-haskell"><span class="hljs-meta">{-# LANGUAGE LambdaCase #-}</span>
<span class="hljs-keyword">import</span> Control.Monad.Reader

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Env</span> = [(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)]</span>

<span class="hljs-comment">-- your specific monad composition</span>
<span class="hljs-comment">-- Eval a is a Reader wrapped in maybe, so the result of runReader can be</span>
<span class="hljs-comment">-- Nothing.</span>
<span class="hljs-comment">-- Although it's a reader monad transformer, the Reader monad is actually</span>
<span class="hljs-comment">-- get wrapped inside the maybe monad. This is why monad transformer get</span>
<span class="hljs-comment">-- composed outside in.</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Eval</span> a = <span class="hljs-type">ReaderT</span> <span class="hljs-type">Env</span> <span class="hljs-type">Maybe</span> a</span>

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Expr</span></span>
   = <span class="hljs-type">Val</span> <span class="hljs-type">Int</span>
   | <span class="hljs-type">Add</span> <span class="hljs-type">Expr</span> <span class="hljs-type">Expr</span>
   | <span class="hljs-type">Var</span> <span class="hljs-type">String</span>
   <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)

<span class="hljs-comment">-- So now you are using a ReaderT, so you know you can just use it</span>
<span class="hljs-comment">-- as usual Reader monad. But besides that, now you can call</span>
<span class="hljs-comment">-- Maybe actions with a lift.</span>
<span class="hljs-title">eval</span> :: <span class="hljs-type">Expr</span> -&gt; <span class="hljs-type">Eval</span> <span class="hljs-type">Int</span>
<span class="hljs-title">eval</span> = \<span class="hljs-keyword">case</span>
  <span class="hljs-type">Val</span> n -&gt; return n
  <span class="hljs-type">Add</span> x y -&gt; <span class="hljs-keyword">do</span>
    a &lt;- eval x   <span class="hljs-comment">-- normal monad bind.</span>
    b &lt;- eval y
    return $ a + b
  <span class="hljs-type">Var</span> x -&gt; <span class="hljs-keyword">do</span>
    env &lt;- ask <span class="hljs-comment">-- use it as a reader, get the environment.</span>
    val &lt;- lift (lookup x env) <span class="hljs-comment">-- use maybe monad.</span>
    return val
<span class="hljs-comment">-- the fact you need to lift the Maybe action is why you unroll monad</span>
<span class="hljs-comment">-- inside out.</span>

<span class="hljs-title">env</span> :: <span class="hljs-type">Env</span>
<span class="hljs-title">env</span> = [(<span class="hljs-string">"x"</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">"y"</span>, <span class="hljs-number">5</span>)]

<span class="hljs-title">ex</span> :: <span class="hljs-type">Eval</span> <span class="hljs-type">Int</span>
<span class="hljs-title">ex</span> = eval (<span class="hljs-type">Add</span> (<span class="hljs-type">Val</span> <span class="hljs-number">2</span>) (<span class="hljs-type">Add</span> (<span class="hljs-type">Val</span> <span class="hljs-number">1</span>) (<span class="hljs-type">Val</span> <span class="hljs-string">"x"</span>)))

<span class="hljs-title">example1</span>, example2 :: <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span>
<span class="hljs-title">example1</span> = runReaderT ex env
<span class="hljs-title">example2</span> = runReaderT ex []
</code></pre>
<h4>How Reader, Writer, State monad are actually implemented</h4>
<p>There is no implementation like this one in libraries.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">State</span> s a = <span class="hljs-type">State</span> { <span class="hljs-title">runState</span> :: <span class="hljs-title">s</span> -&gt; (<span class="hljs-title">a</span>, <span class="hljs-title">s</span>) }</span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> (<span class="hljs-type">State</span> <span class="hljs-title">s</span>) <span class="hljs-keyword">where</span></span>
  return a = <span class="hljs-type">State</span> $ \s -&gt; (s, a)
  (<span class="hljs-type">State</span> x) &gt;&gt;= f = <span class="hljs-type">State</span> $ \s -&gt;
    <span class="hljs-keyword">let</span> (a', s') = x s
     <span class="hljs-keyword">in</span> runState (f a') s'

<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Reader</span> r a = <span class="hljs-type">Reader</span> [ runReader :: r -&gt; a ]</span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> (<span class="hljs-type">Reader</span> <span class="hljs-title">r</span>) <span class="hljs-keyword">where</span></span>
  return a = <span class="hljs-type">Reader</span> $ \r -&gt; a
  (<span class="hljs-type">Reader</span> x) &gt;&gt;= f = <span class="hljs-type">Reader</span> $ \r -&gt; runReader (f $ x r) r
</code></pre>
<p>They actually are defined as more specific version of there corresponding monad</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Reader</span> r a = <span class="hljs-type">ReaderT</span> r <span class="hljs-type">Identity</span> a</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">State</span> s a = <span class="hljs-type">StateT</span> s <span class="hljs-type">Identity</span> a</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Wiriter</span> w a = <span class="hljs-type">WriterT</span> w <span class="hljs-type">Identity</span> a</span>
</code></pre>
<p>Again, what is identity monad? <code>Identity</code> is to mondas, functors, applicative as 0 to numbers. You use it when you want a monad to do nothing.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Identity</span> a = <span class="hljs-type">Identity</span> {<span class="hljs-title">runIdentity</span> :: <span class="hljs-title">a</span>}</span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">Identity</span> <span class="hljs-keyword">where</span></span>
  f &lt;$&gt; m = <span class="hljs-type">Identity</span> (f $ runIdentity m)
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> <span class="hljs-type">Identity</span> <span class="hljs-keyword">where</span></span>
  fa &lt;*&gt; fm = <span class="hljs-type">Identity</span> $ (runIdentity fa) (runIdentity fm)
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> <span class="hljs-type">Identity</span> <span class="hljs-keyword">where</span></span>
  return a = <span class="hljs-type">Identity</span> a
  m &gt;&gt;= f = k (runIdentity m)
</code></pre>
<p>It's one of those monad that stand lone they seems pretty useless, but are necessary when they get composed with other monads.</p>
<p>A benefit of it is, say you have a reader monad, it will have the same function to call as the reader transformer because it's defined for the more generic form. <code>ask</code> is defined for reader transformer so you can call it on any reader transformers.</p>
<h4>mtl library</h4>
<p>We mentioned above that too many layers of monad transformer is awkard to use, you need to have right amount of <code>lift</code> to reach the level you want, and it doesn't seem to scale very well: it's hard to imagine to manipulate a 20 layers tall monad transformer.</p>
<p>This is the motivatoin of <code>mtl</code> library. <code>mtl</code> is the most popular way to manage effect with monad in hasekll. You can avoid use monad transformer at all with algebraic effect and <code>fuesd-effect</code>, but if you want to use a lot of monads <code>mtl</code> is a mature solution.</p>
<h4>How to use mtl</h4>
<p>When you are using mtl you dont't really use *T style transformer all the time. Some example instances from mtl</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">MonadState</span> s (<span class="hljs-type">StateT</span> <span class="hljs-title">s</span> <span class="hljs-title">m</span>)
<span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">MonadReader</span> r (<span class="hljs-type">ReaderT</span> <span class="hljs-title">r</span> <span class="hljs-title">m</span>)
<span class="hljs-keyword">instance</span> (<span class="hljs-type">Monoid</span> <span class="hljs-title">w</span>, <span class="hljs-type">Monad</span> <span class="hljs-title">m</span>) =&gt; <span class="hljs-type">MonadWriter</span> w (<span class="hljs-type">WriterT</span> <span class="hljs-title">w</span> <span class="hljs-title">m</span>)
</span></code></pre>
<p>This solve the multiple lift problems a of multiple transformers. mtl is by far the most popular effect system haskell ppl use.</p>
<h4>New type deriving</h4>
<p>Common technique being used with <code>mtl</code>. We already know new type is a very good way to let compiler help us differentiate two same types with different semantic meanings. There are other ways to use new types.</p>
<p>With newtype deriving and <code>mtl</code> we can produce flattened transformer types without needing to do endless lift and return.</p>
<p>An example of a stack machine.</p>
<pre><code class="language-haskell"><span class="hljs-meta">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="hljs-meta">{-# LANGUAGE LambdaCase #-}</span>
<span class="hljs-keyword">import</span> Control.Monad.Reader
<span class="hljs-keyword">import</span> Control.Monad.Writer
<span class="hljs-keyword">import</span> Control.Monad.State

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Stack</span> = [<span class="hljs-type">Int</span>]</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Output</span> = [<span class="hljs-type">Int</span>]</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Program</span> = [<span class="hljs-type">Instr</span>]</span>

<span class="hljs-comment">-- What it is saying is that VM is a combination of</span>
<span class="hljs-comment">-- Readable program, writable output, and a stack state.</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">VM</span> a = <span class="hljs-type">ReaderT</span> <span class="hljs-type">Program</span> (<span class="hljs-type">WriterT</span> <span class="hljs-type">Output</span> (<span class="hljs-type">State</span> <span class="hljs-type">Stack</span>)) a</span>

<span class="hljs-comment">-- Comp is just a newtype wrapper on top of VM. You can derive</span>
<span class="hljs-comment">-- typeclass for it.</span>
<span class="hljs-comment">-- See how many code you can derive</span>
<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Comp</span> a = <span class="hljs-type">Comp</span> { <span class="hljs-title">unComp</span> :: <span class="hljs-type">VM</span> <span class="hljs-title">a</span> }</span>
  <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Functor</span>, <span class="hljs-type">Applicative</span>, <span class="hljs-type">Monad</span>,
            <span class="hljs-type">MonadReader</span> <span class="hljs-type">Program</span>,
            <span class="hljs-type">MonadWriter</span> <span class="hljs-type">Output</span>,
            <span class="hljs-type">MonadState</span> <span class="hljs-type">Stack</span>)
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Instr</span> = <span class="hljs-type">Push</span> <span class="hljs-type">Int</span> | <span class="hljs-type">Pop</span> | <span class="hljs-type">Puts</span></span>

<span class="hljs-comment">-- With mtl derived, you don't need lift all the time to</span>
<span class="hljs-comment">-- use monad on different layers.</span>
<span class="hljs-title">evalInstr</span> :: <span class="hljs-type">Instr</span> -&gt; <span class="hljs-type">Comp</span> ()
<span class="hljs-title">evalInstr</span> instr = \<span class="hljs-keyword">case</span>
  <span class="hljs-type">Pop</span> -&gt; modify tail  <span class="hljs-comment">-- using the `State Stack`</span>
  <span class="hljs-type">Push</span> -&gt; modify (n:)
  <span class="hljs-type">Puts</span> -&gt; <span class="hljs-keyword">do</span>
    tos &lt;_ gets head
    tell [tos]        <span class="hljs-comment">-- using the `WriterT Output`</span>

<span class="hljs-comment">-- Just another example of using the transformer.</span>
<span class="hljs-title">eval</span> :: <span class="hljs-type">Comp</span> ()
<span class="hljs-title">eval</span> = <span class="hljs-keyword">do</span>
  instr &lt;- ask  <span class="hljs-comment">-- using ReaderT</span>
  <span class="hljs-keyword">case</span> instr <span class="hljs-keyword">of</span>
    [] -&gt; return ()
    (i:is) -&gt; evalInstr i &gt;&gt; local (const is) eval <span class="hljs-comment">-- using ReaderT again</span>

<span class="hljs-comment">-- What it does:</span>
<span class="hljs-comment">-- * flip evalState parameter, so we can setup the initial stack [].</span>
<span class="hljs-comment">-- * note eval :: Comp (). It is our comp in term level.</span>
<span class="hljs-comment">--   unComp get the underlying value out from the new type.</span>
<span class="hljs-comment">-- * note runReaderT :: (r -&gt; m a) -&gt; ReaderT r m a</span>
<span class="hljs-comment">-- * note execWriterT :: WriterT w m a -&gt; m w</span>
<span class="hljs-comment">-- You unwrap the monad transformer with the same order of how transformers</span>
<span class="hljs-comment">-- are stacked together.</span>
<span class="hljs-title">execVM</span> :: <span class="hljs-type">Program</span> -&gt; <span class="hljs-type">Output</span>
<span class="hljs-title">execVM</span> = flip evalState [] . execWriterT . runReaderT (unComp eval)

<span class="hljs-comment">-- Define the program</span>
<span class="hljs-title">program</span> :: <span class="hljs-type">Program</span>
<span class="hljs-title">program</span> = [
  <span class="hljs-type">Push</span> <span class="hljs-number">42</span>,
  <span class="hljs-type">Push</span> <span class="hljs-number">27</span>,
  <span class="hljs-type">Pop</span>,
  <span class="hljs-type">Puts</span>,
  <span class="hljs-type">Pop</span>
]

<span class="hljs-comment">-- * note mapM_ :: (Foldable t, Monad m) =&gt; (a -&gt; m b) -&gt; t a -&gt; m ()</span>
<span class="hljs-comment">--   It's the function used to execute effect over a Fodable</span>
<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = mapM_ print $ execVM program
</code></pre>
<h4>Monad morphisms with mmorph</h4>
<p>You can <code>lift :: Moand m =&gt; m a -&gt; t m a</code> to lift an action into the transformer, but also there are cases that you want to transform your existed monad transformers to new transformers; such transformation can be done with the help of <code>mmorph</code> library.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- map a function from a base monad to a function over a transformed monad.</span>
<span class="hljs-title">hoist</span> :: <span class="hljs-type">Monad</span> m =&gt; (<span class="hljs-keyword">forall</span> a. m a -&gt; n a) -&gt; t m b -&gt; t n b

<span class="hljs-comment">-- generalize an Identity monad into another monad.</span>
<span class="hljs-comment">-- For instance, we already know that State s a = StateT s Identity a.</span>
<span class="hljs-comment">-- With generalize we can turn StateT s Identity a to StateT s m a.</span>
<span class="hljs-title">generalize</span> :: <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">Identity</span> a -&gt; m a
</code></pre>
<p>Example of usage</p>
<pre><code class="language-haskell"><span class="hljs-keyword">import</span> Control.Monad.State
<span class="hljs-keyword">import</span> Control.Monad.Morph

<span class="hljs-comment">-- define a state as StateT [Int] Identity a</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Eval</span> a = <span class="hljs-type">State</span> [<span class="hljs-type">Int</span>] a</span>

<span class="hljs-title">runEval</span> :: [<span class="hljs-type">Int</span>] -&gt; <span class="hljs-type">Eval</span> a -&gt; a
<span class="hljs-title">runEval</span> = flip evalState

<span class="hljs-title">pop</span> :: <span class="hljs-type">Eval</span> <span class="hljs-type">Int</span>
<span class="hljs-title">pop</span> = gets head &gt;&gt;= \top -&gt; modify tail &gt;&gt; return top

<span class="hljs-title">push</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Eval</span> ()
<span class="hljs-title">push</span> x = modify (x:)

<span class="hljs-title">ev1</span> :: <span class="hljs-type">Eval</span> <span class="hljs-type">Int</span>
<span class="hljs-title">ev1</span> = push <span class="hljs-number">3</span> &gt;&gt; push <span class="hljs-number">4</span> &gt;&gt; pop &gt;&gt; pop

<span class="hljs-comment">-- hoist and generalize help you bring the State monad into</span>
<span class="hljs-comment">-- a state monad transformer with IO stacked on top.</span>
<span class="hljs-title">ev2</span> :: <span class="hljs-type">StateT</span> [<span class="hljs-type">Int</span>] <span class="hljs-type">IO</span> ()
<span class="hljs-title">ev2</span> = hoist generalize ev1 &gt;&gt;= \result -&gt;
  liftIO $ putStrLn $ <span class="hljs-string">"Result: "</span> ++ show result
</code></pre>
<h4>Draw back of mtl</h4>
<p>There are lots of problems with <code>mtl</code>.</p>
<h6>n² instance problem / instance boilerplate problem.</h6>
<p>To add a new custom transformer into a existing <code>mtl</code> transformer stack we need to derive a large amount of instances that do nothing but mostly lift.</p>
<h6>Monad transformer composition is not commutative.</h6>
<pre><code class="language-haskell"><span class="hljs-title">stateExcept</span> :: <span class="hljs-type">StateT</span> s (<span class="hljs-type">Except</span> e) a -&gt; s -&gt; <span class="hljs-type">Either</span> e (a, s)
<span class="hljs-title">stateExcept</span> m s = runExcept (runStateT m s)

<span class="hljs-title">exceptState</span> :: <span class="hljs-type">ExceptT</span> e (<span class="hljs-type">State</span> s) a -&gt; s -&gt; (<span class="hljs-type">Either</span> e a, s)
<span class="hljs-title">exceptState</span> m s = runState (runExceptT m) s
</code></pre>
<h2>Free Monad</h2>
<h4>Polysemy</h4>
<h2>Algebraic effect</h2>
<h4>Fused Effect</h4>
<h2>Lenses</h2>
