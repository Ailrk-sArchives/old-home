<h1>haskell Deriving and ski combinator</h1>
<h2>GHC Extensions for deriving</h2>
<p>Whether a type can derive a typeclass is somewhat unintuitive. The rule of thumbs, haskell take the most conservative dicision. If there is ambiguity about the deriving it will not be able to derive.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">T0</span> f a = <span class="hljs-type">MkT0</span> a <span class="hljs-keyword">deriving</span> <span class="hljs-type">Eq</span></span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">T1</span> f a = <span class="hljs-type">MkT1</span> (<span class="hljs-title">f</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">deriving</span> <span class="hljs-type">Eq</span></span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">T2</span> f a = <span class="hljs-type">MkT2</span> (<span class="hljs-title">f</span> (<span class="hljs-title">f</span> <span class="hljs-title">a</span>)) <span class="hljs-keyword">deriving</span> <span class="hljs-type">Eq</span></span>
</code></pre>
<p>First two cases are able to be derived directly. However, the third one can lead to unterminated instances, so by default Haskell rejects it.</p>
<h5>{-# LANGUAGE StandaloneDeriving #-}</h5>
<pre><code class="language-haskell"><span class="hljs-meta">{-# StandaloneDeriving #-}</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Foo</span> a = <span class="hljs-type">Bar</span> a | <span class="hljs-type">Baz</span> <span class="hljs-type">String</span> <span class="hljs-keyword">deriving</span> instance <span class="hljs-type">Eq</span> a =&gt; <span class="hljs-type">Eq</span> (<span class="hljs-type">Foo</span> <span class="hljs-title">a</span>)</span>
</code></pre>
<p>This extension allows you to derive a typeclass based on a specific typeclass instance.</p>
<h4>{-# LANGUAGE Derive* #-}</h4>
<pre><code class="language-haskell"><span class="hljs-meta">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="hljs-meta">{-# LANGUAGE DeriveApplicative #-}</span>
<span class="hljs-meta">{-# LANGUAGE DeriveTraversable #-}</span>
<span class="hljs-meta">{-# LANGUAGE DeriveFoldable #-}</span>
</code></pre>
<p>Derive the most obvious instance respectively.</p>
<h4>{-# LANGUAGE DeriveVia #-}</h4>
<p>Derive anything</p>
<pre><code class="language-haskell"><span class="hljs-meta">{-# LANGUAGE DeriveVia #-}</span>
</code></pre>
<h2>SKI Combinator</h2>
<p>All lambda calculus can be encoded with three basic combinator s k i.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-------------------------------------------------------------</span>
<span class="hljs-comment">-- Define some SKI combinators.</span>
<span class="hljs-comment">-------------------------------------------------------------</span>
<span class="hljs-title">s</span> :: (env -&gt; a -&gt; b) -&gt; (env -&gt; a) -&gt; env -&gt; b
<span class="hljs-title">s</span> x y z = (x z) (y z)

<span class="hljs-title">i</span> :: a -&gt; a
<span class="hljs-title">i</span> a = a

<span class="hljs-title">k</span> :: a -&gt; b -&gt; a
<span class="hljs-title">k</span> = const
</code></pre>
<p>Interestingly, <code>S</code> combinator is actually an instance of applicative for reader.</p>
