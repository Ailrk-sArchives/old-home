<h2>SKI Combinators</h2>
<h4>Overview of lambda calculus</h4>
<h4>Motivation of SKI combinator</h4>
<h4>Formal defination</h4>
<h2>GHC Extensions for deriving</h2>
<p>Whether a type can derive a typeclass is somewhat unintuitive. The rule of thumbs, haskell take the most conservative dicision. If there is ambiguity about the deriving it will not be able to derive.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">T0</span> f a = <span class="hljs-type">MkT0</span> a <span class="hljs-keyword">deriving</span> <span class="hljs-type">Eq</span></span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">T1</span> f a = <span class="hljs-type">MkT1</span> (<span class="hljs-title">f</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">deriving</span> <span class="hljs-type">Eq</span></span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">T2</span> f a = <span class="hljs-type">MkT2</span> (<span class="hljs-title">f</span> (<span class="hljs-title">f</span> <span class="hljs-title">a</span>)) <span class="hljs-keyword">deriving</span> <span class="hljs-type">Eq</span></span>
</code></pre>
<p>First two cases are able to be derived directly. However, the third one can lead to unterminated instances, so by default Haskell rejects it.</p>
<h5>{-# LANGUAGE StandaloneDeriving #-}</h5>
<pre><code class="language-haskell"><span class="hljs-meta">{-# StandaloneDeriving #-}</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Foo</span> a = <span class="hljs-type">Bar</span> a | <span class="hljs-type">Baz</span> <span class="hljs-type">String</span> <span class="hljs-keyword">deriving</span> instance <span class="hljs-type">Eq</span> a =&gt; <span class="hljs-type">Eq</span> (<span class="hljs-type">Foo</span> <span class="hljs-title">a</span>)</span>
</code></pre>
<p>This extension allows you to derive a typeclass based on a specific typeclass instance.</p>
<h4>{-# LANGUAGE Derive* #-}</h4>
<pre><code class="language-haskell"><span class="hljs-meta">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="hljs-meta">{-# LANGUAGE DeriveApplicative #-}</span>
<span class="hljs-meta">{-# LANGUAGE DeriveTraversable #-}</span>
<span class="hljs-meta">{-# LANGUAGE DeriveFoldable #-}</span>
</code></pre>
<p>Derive the most obvious instance respectively.</p>
<h4>{-# LANGUAGE DeriveVia #-}</h4>
<p>Derive anything</p>
<pre><code class="language-haskell"><span class="hljs-meta">{-# LANGUAGE DeriveVia #-}</span>
</code></pre>
