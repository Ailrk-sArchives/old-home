<h1>Parser combinator in Haskell (in repo Notes/haskell..pinciple../parser )</h1>
<h5>1. How to define parser in haskell?</h5>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Parser</span> a = <span class="hljs-type">Parser</span> {<span class="hljs-title">parse</span> :: <span class="hljs-type">String</span> -&gt; [(<span class="hljs-title">a</span>, <span class="hljs-type">String</span>)]}</span>
</code></pre>
<p>Essentially a function</p>
<h5>2. It looks so similar with State.</h5>
<p>Parser is probably one of the most typical use case for a state monad.  You need some place to hold the position in current input stream for the entire parsing process. You can probably implement a parser with StateT alone.</p>
<h5>3. What is State after all?</h5>
<p>Although it is called <code>State</code>,</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">State</span> s a = {<span class="hljs-title">runState</span> :: <span class="hljs-title">s</span> -&gt; (<span class="hljs-title">a</span>, <span class="hljs-title">s</span>)}</span>
</code></pre>
<p>It's really just a reader that transform current state to the next one, and the actual state is the parameter of runState. So essentially State encapsulate all the computation involves with the state <code>s</code> in to a monad where the state is passed as parameter by default.</p>
<h5>4. Some intuitions about typeclasses for Parser? Like what does they do?</h5>
<p>Functor:<br>
simply apply a funciton to parsed result.<br>
You can use it to make a slightly different parser based on an existed one.<br>
Applicative:<br>
pure construct a Parser with the given result regardless what the state is.<br>
(&lt;*&gt;) just like how applicative work for List, but replacingf the state along the way.<br>
Monad:<br>
Again, like applicative, it works like List monad.<br>
MonadPlus:<br>
mplus means concat the result of two parser into one list.<br>
identity is a parser that return an empty list.<br>
Alternative<br>
an empty list is regard as the failure case.</p>
<h5>5. Conclusion about typeclasses with context</h5>
<p>If a typeclass holds some context, it might has higher kind. For example, Monad is <code>* -&gt; *</code><br>
When you have the same typeclass for different types:</p>
<p>The abstract notion of the typeclass will not change. Namely the typeclass will always works according to its type signature. For a functor the notion is to apply (a -&gt; b) into the value in the functorial context. No matter what structure the context has, this goal will always be achieved.</p>
<p>On the other hand, what will happen in the context during the computation depends on types. For Parser Functor it will replace the old state with a new one, while for a Maybe functor will return Some or None value based on what value the function is applied to.</p>
<p>Different typeclasses for the same type usually have similar effect. Functor, Applicative, Monad for State all substitute old state with the new one. Similarly those typeclasses for Maybe all return Nothing if a value is absent.</p>
<p>It's a pretty rough intuition, I might need to learn some Cat theory?</p>
<h5>6. Some intuition about parser combinator in general</h5>
<p>Each parser is a function. You can make more complicated parsers based on simpler one by combining one parser function to another. In haskell some of this combination mechanics can be regard as functionalities provided by typeclasses. For instance, Alternative is a very good choice for implement option combinator, you can just implement that.</p>
<h5>7. How many parser combinators are there?</h5>
<pre><code>item: parse for any character.
sequence: parse one thing, then parse another thing. (can be thought as monad &gt;&gt;)
option: parse either one or another. (alternative &lt;|&gt;)
some: like regex +
many: like regex *
oneOf: parse if the string match one of the element
chianl: for parsing left recursive grammar
These are some basic combinators.
</code></pre>
<h5>8. Rough process of Parsec?</h5>
<pre><code>Define Tokens with Tok.LanguageDef () // a record of all token definitions.
Define lexers `Tok.TokenParser ()`
Define your AST
Parse from token into AST
Eval or codeGen depends on what you want to do
</code></pre>
