<h1>Parser combinator in Haskell (in repo Notes/haskell..pinciple../parser )</h1>
<h5>1. Parser</h5>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Parser</span> a = <span class="hljs-type">Parser</span> {<span class="hljs-title">parse</span> :: <span class="hljs-type">String</span> -&gt; [(<span class="hljs-title">a</span>, <span class="hljs-type">String</span>)]}</span>
</code></pre>
<p>Essentially a function</p>
<h5>2. It looks very similar with State.</h5>
<p>Parser is probably one of the most typical use case for a state monad.  You need some place to hold the position in current input stream for the entire parsing process. You can probably implement a parser with StateT alone.</p>
<h5>3. What is State after all?</h5>
<p>Although it is called <code>State</code>,</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">State</span> s a = {<span class="hljs-title">runState</span> :: <span class="hljs-title">s</span> -&gt; (<span class="hljs-title">a</span>, <span class="hljs-title">s</span>)}</span>
</code></pre>
<p>It's really just a reader that transform current state to the next one, and the actual state is the parameter of runState. So essentially State encapsulate all the computation involves with the state <code>s</code> in to a monad where the state is passed as parameter by default.</p>
<h5>What is context?</h5>
<p>It's a very sloppy note with bunch of heuristics. I already modified this text once but still doesn't seem quite right. Maybe the only way to know it better is to learn some type theory.<br>
When doing <code>Functors</code> or <code>Monad</code> people talks about context without good examples. First to denote a context with type system you need higher kinded type. With a type <code>f a</code> of kind <code>* -&gt; *</code> you can have <code>f</code> as a type operator with a type parameter <code>a</code>, or a type indexed by <code>a</code>. And when you are defining things like functor you define <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>, which in type level you are saying there exists a <code>fmap</code> implementation for this higher kinded type that if you pass <code>a -&gt; b</code> and a value of this type it will gives you <code>f b</code> back. These are all denoted at type level, so no real context involved so far.<br>
But when you are defining the <code>fmap</code> in term level, you can bring some meaning of the context. For instance, if you have <code>Maybe a</code>, the value of type <code>Maybe a</code> can be <code>Just a</code> or <code>Nothing.</code> It's the present of <code>Maybe</code> in type system make it possible, or <code>Maybe</code> attached more meaning to <code>a</code>.<br>
Another example <code>State s a</code>. At type level you can think it as value with type <code>a</code> surrounded by <code>State s</code>. In definition <code>runState :: s -&gt; (a, s)</code> is what really defines the <code>context</code>. It's a function reads a value s with type <code>s</code>, and return the value <code>a</code> and a new state. While executing <code>runState</code> the context will always exists along a, which is the point of state (pass the state implicitly).</p>
<h5>Parser combinator</h5>
<ul>
<li>Each parser is a function.</li>
<li>You can make more complicated parsers based on simpler one by combining one parser function to another.</li>
<li>In Haskell some of combinators can be achieve by implementing some typeclass. For instance, Alternative can be option combinator since they have the same type.</li>
</ul>
<h5>Common combinators</h5>
<p>item: parse for any character.<br>
sequence: parse one thing, then parse another thing. (can be thought as monad &gt;&gt;)<br>
option: parse either one or another. (alternative &lt;|&gt;)<br>
some: like regex +<br>
many: like regex *<br>
oneOf: parse if the string match one of the element<br>
chianl: for parsing left recursive grammar<br>
These are some basic combinators.</p>
<h5>Parsec</h5>
<p>Everybody use library to write parser.</p>
<ul>
<li>Define Tokens with Tok.LanguageDef () // a record of all token definitions.</li>
<li>Define lexers <code>Tok.TokenParser ()</code></li>
<li>Define your AST</li>
<li>Parse from token into AST</li>
<li>Eval or codeGen depends on what you want to do</li>
</ul>
