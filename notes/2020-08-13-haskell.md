-- tag note haskell data-structures
-- title Take some haskell notes
-- date 2020-08-13
-- source https://en.wikibooks.org/wiki/Haskell/Monad_transformers
;;
# Take some haskell notes
## Monad Transformer
How do you use several monads at once?

## Typeclass relationship
This map is kinda cool so I put it here.
```
        Haskell Typeclass relationships, definition and intuitions

     Functor   ~Apply...........Semigroup
       |                             |
       |                             |
   +---+-----+                       V
   |   |     |        ............Monoid ..Catgegory
   |   | .Applicative  .             .      |
   |   | .      |      .             .      |
   |   | .      +--------------+     .      |
   |   | .      |      .       |     .      |
   |   | .      |   ......     |     .......|....................
   |   | .      |   .    .     |     .      |                   .
~  V   | .      |   .    .     V     .      V                   .
Comonad| .      V   . Folable Monad...   Arrow+->ArrowZero->ArrowPlus
       | . Alternative |         |   .        |
       | .             |  +------+----------+ +--+----+
       | .             |  |      |   .      | |  |    |
       V .             |  V      V   .      | |  |    V
    Traversable  <------+ MonadMix MonadPlus| |  | ArrowLoop
                                            | |  |
                                            | |ArrowChoice
                                            | V
                                         ArrowApply
```

- Solid arrows point from the general to specific.
- Dotted lines indicatte some other relationship.
- Monad and ArrowApply are equivalent.
- Apply and Comonad are greyed out since they are not actually in the standard hasekell libraries.

## Data.Vector
Vector is easier to ue than `array`, and is the most common array type in haskell. You see people use it all the time. There are twop flavours: mutable and immutable.

```haskell
data Vector a
data MVector a
```

Most list funcitons also work for vector. But there are some specific apis functions

```haskell

(!?) :: Vector a -> Int -> Maybe a

-- o(1) without boud checking.
unsafeIndex :: Vector a -> Int -> a
unsafeHead :: Vector a -> a
unsafeTail :: Vector a -> a

-- monadic indexing
indexM :: Monad m => Vector a -> Int -> m a
...

-- slicing
-- O(1) slice without copying it.
slice :: Int -> Int -> Vector a -> Vector a
init :: Vector a -> Vector a
tail :: Vector a -> Vector a
take :: Int -> Vector a -> Vector a
drop :: Int -> Vector a -> Vector a
splitAt :: Int -> Vector a -> (Vector a, Vector a)
splitAt n v = (take n v, drop n v)

-- bulk updates. Update the index in [(Int a)]
(//) :: Vector a -> [(Int a)] -> Vector a

-- mutable vectors
freeze :: PrimeMonad m => MVector (PrimeState m) a -> m (Vector a)
thaw :: PrimeMonad m =>  Vector a -> MVector (PrimeState m) a
copy :: PrimeMonad m => MVector  (PrimeState m) a -> vector a -> m ()
```

## Data.Array
Array are by default immutable boxed value. Boxed means data are just ordinary haskell value and are evaluated lazily. There are 9 types of array constructors exposed from `Data.Array`. Kinda bloated. Because of its rich features, it is a perfect opportunity for studying how haskell expressive various data structures.

```
====================================================================
             Immutable          IO monad         ST monad
====================================================================
Standard       Array             IOArray          STArray
              DiffArray
====================================================================
Unboxed       UArray             IOUArray         STUArray
             DiffUArray         StorableArray
====================================================================
```

Some types and typeclass defined in `array`

``` haskell
-- i is the index type, e is the element type
data Array i e
-- take index value pair in range of (i, i)
array :: Ix i => (i, i) -> [(i, e)] -> Array i e
-- just take part of the list into an array.
listArray :: Ix i => (i, i) -> [e]  -> Array i e
```

#### Baisc arrays
The basical types are `Array`, `IOArray`, and `STArray`. They are boxed and have different immutabilities. Note that because if you don't have IO or ST everything is pure functions, so update (//) for Array is literally replace the old array with a new one, and compiler will not optmize that to a stateful operation. If you want to have a efficient update you can convert it to STArray for mutation and then convert it back to immutable.
```haskell
-- Immutable arrays
import Data.Array
import Data.Array.ST
import Data.Array.IO
import Control.Monad.St

buildPair :: (Int, Int)
buildPair = let arr = listArray (1, 10) (repeat 37) :: Array Int Int
                arr' = arr // [(1, 64)]
             in (arr ! 1, arr' ! 1)

-- Mutable IO arrays
-- It's similar to IORefs but contains multiple values.
-- Because `newArray` is overloaded, you need to annotate it.
main = do
    arr <- newArray (1, 10) 37 :: IO (IOArray Int Int)
    a <- readArray arr 1
    write arr 1 64
    b <- readArray arr 1
    print (a, b)

-- Like how IORef is related to STRef, STArray is a more generic
-- version of IOArray.
stArray = newArray (1, 10) 37 :: ST s (STArray Int Int)

-- Freezing and thawing
modifyAsST :: Array Int Int -> Array Int Int
modifyAsST arr = runST $ do
    starr <- thaw arr
    writeArray arr 1 64
    newarr <- freeze starr
    return newarr
```

#### Diff arrays
Updating an `Array` will just create a new copy of if, while using an `IOArray` or a `STArray` requires monadic code. `DiffArray` helps provide pure interface with efficient mutation uderneath.

```haskell
-- an example of using diff array. It forces evaluating element
-- a and b before the update.
main = do
    let arr = listArray (1, 1000) [1..1000] :: DiffArray Int Int
        a = arr ! 1
        b = arr ! 2
        arr2 = a `seq` b `seq` (arr // [(1, 37), (2, 64)])
    print (a, b, c)
```

#### Unboxed arrays
Most implementations of lazy evaluation usually will have value being represented as pointers to either the value itself, or code for computing the value. This is an extra indirection that requires an extra tag at the runtime. The indirection is called `box`. Like `box` in rust refer to a pointer to some memory on the heap, and `box` in other VM languages generally means a object. Boxed value are easy to manage, but the extra taggin information can make it inefficient in many cases (like an array...)

Unboxed arrays have the same api, it's just their elements are evaluated eagerly without involvement of lazyniess.

#### Storable arrays
`IOUArray` serve the purpose of mutable unboxed array, but it is not transferable to foreign routines, for instance, turn into C array. For this purpose you can use `StorableArray` which is also mutable but will be allocated non-relocatable ghc heap. Doing so allows it has a fixed address and C routine and use it to find the array.

```haskell
-- this enable c extensions
{-# OPTIONS_GHC -fglasgow-exts #-}
import Data.Array.Storable
import Foreign.Ptr
import Foreign.C.Types

main = do
    arr <- newArray (1, 10) 37 :: IO (StorableArray Int Int)
    withStorableArray arr
        (\ptr -> memset ptr 0 40)
    b <- readArray arr 1
    print (a, b)

foreign import call unsafe "string.h"
    memset :: Ptr a -> CInt -> CSize -> IO ()
```

#### Unsafe operations
`freeze/thaw` copy the entire array when doing the conversion. If you are sure the mutable array will not be modified after it is turned into immutable array, or an immutable array will not be used after it is turned into mutable, you can use `unsafeFreeze/unsafeThaw` which do inplace replacement.

#### Unsafe operations and thread safe
`unsafe*` operations in general modifies memory, and they should not be used with multi-threaded access to the array.

#### Conclusion
Array interface resembles a lot to many other data  structures in haskell. For instance, List and ByteString. A haskell library can have these notion of `safe` and `unsafe`, `immutable` and `IO/ST`, `strict` and `lazy` (`Boxed` and  `Unboxed`) etc., and this is something not very common in other languages.

Different versions of apis arranged in different modules of the package, so if you want to use multiple of them you need to import themfrom their specific module. This is why the first screen of a haskell program is usually filled with imports.
