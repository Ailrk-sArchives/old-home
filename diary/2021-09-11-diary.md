-- tag
-- title 碎碎念　之 二 「程序」
-- time 2021-09-11
-- source 我

;;

# 碎碎念　之 二 「程序」

一直在想程序到底是什么东西。

最早，计算机都没有个样子，　程序是

1949年之后，程序都是

1957年之后，程序是

1985年之后，程序是

2000年之后，程序是

编译器把高级语言转换成一层一层的中间表示，最后一定会在某个时机变成某个ISA的机器码，然后在某个特定的时候被CPU　fetch, decoded, execute。CPU本身也是一个解释器，只解释特定的ISA指令。编译器只是在保证语义相同的前提下做格式的转化，真正运行起来的程序都是解释执行的，也就是和所谓的动态语言有相同的性质：程序在运行的时候拥有代码的所有信息，也就不存在编译语言的运行时得不到编译期信息的问题。lisp　macro可以运行时生成新的代码，所有的动态语言都可以在运行时判断一个值是是某个类型。编译语言大多在编译器做类型检查，运行时做type erasure。类型检查是优点，但缺少运行时类型信息完全是为了性能的考量。这就像一票语言有异常却没有stack trace一样。理想情况下当然是能访问到的信息越多越好， 如果不是为了zero cost abstraction C++ template 完全没有必要做成monomorphiazation, 编译型语言带运行时类型信息也完全没有什么不可以的。

IBM 360是早期的

大多是Algol 60程序都是写在punch card上的，　

lambda calculus 和 turing machine等价，但我们并没有直接运行lambda calclus的硬件。曾经有人尝试做SECD machine的实体版本，但最终也没能引起多大的反响。

depandent type　类型可以依赖于值，那什么东西是编译期可以知道的，什么东西是运行时才能知道的？

Curry Howard isomorphism　把直接吧编程语言和formal logic　画上了等号。Proposition as types，到底是什么意思？

当然不管上层的理论有多么丰富多彩，所有程序还是最终编译成一条条指令被cpu直接执行。

编译是一个inductive的过程, cpu是这个链条的端点。

所以程序实在是一个很笼统的概念。它没有形状，没有实体，而是寄宿在一个个不同的表示上。

有了各种表达程序的方式，我们还想要具体运行程序

不变的特性是定义一些数据和一些对数据的操作，然后某些操作会返回一个最后的结果来。

编程确实是一项技能，但绝对不仅仅是熟能生巧的，广博的知识面是防止陷入局部最有的唯一方法。
