<h2>Destructive move</h2>
<p>Move semantics is simple! It's derived from idioms that people adopt to avoid expensive heap allocations. Actually, it's just <code>memcpy</code>: If I have an object on the stack that holds a pointer to a large piece of heap memory, and I want to give it away to someone else (e.g another object, or a function), there are two things I need to do: first, I copy the object on the stack byte by byte to the new location; second, I invalidate the old object so nobody can touch it.</p>
<p>This simple model is called <code>destructive move</code>, which is, very unfortunately, not how C++ move semantics work. The existence of exceptions and the ability to have self referential structs force us to have a much more complicated mechanism.</p>
<h3>What does it mean to move?</h3>
<p><code>Move</code> is a higher order concept. For CPU, there is no sense of moving. The only way to relocate a piece of memory is to copy: We can read some bytes, put it into the register, then write them into another address. When we talk about moving a byte from address A to address B, it's from the point of view that before we &quot;move&quot;, the byte is at address A, and after we move it's at address B. The object is &quot;moved&quot; if you ignore the fact that copying was actually happening behind the scene and there is a moment that the same data exists at both addresses.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Movable</span> {</span>
  <span class="hljs-keyword">bool</span> not_moved = <span class="hljs-literal">true</span>;
  T content_;
  T (*clone_)(<span class="hljs-keyword">void</span> *);
  Movable(Movable&lt;T&gt; &amp;to, T *from)
    { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">memcpy</span>(&amp;to.content_, from, <span class="hljs-keyword">sizeof</span>(T)); }

<span class="hljs-keyword">public</span>:
  Movable(Args &amp;&amp;...args)
      : content_(T{<span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...}),
        clone_([](<span class="hljs-keyword">void</span> *ptr) -&gt; T { <span class="hljs-keyword">return</span> *<span class="hljs-keyword">static_cast</span>&lt;T *&gt;(ptr); }) {}

  T *<span class="hljs-keyword">operator</span>-&gt;() {
    assert(not_moved &amp;&amp; <span class="hljs-string">"access moved object"</span>);
    <span class="hljs-keyword">return</span> &amp;content_;
  }

  <span class="hljs-function">Movable <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>{
    assert(not_moved &amp;&amp; <span class="hljs-string">"access moved object"</span>);
    <span class="hljs-keyword">return</span> clone_(&amp;content_);
  }

  <span class="hljs-function">Movable <span class="hljs-title">destructive_move</span><span class="hljs-params">(Movable&lt;T&gt; &amp;to)</span> </span>{
    assert(not_moved &amp;&amp; <span class="hljs-string">"access moved object"</span>);
    not_moved = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> Movable(to, &amp;content_);
  }
};
</code></pre>
<p>Try it</p>
<pre><code class="language-C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span> {</span>
  <span class="hljs-keyword">int</span> *data, <span class="hljs-built_in">size</span>;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">report</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fill_8</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">/* allocate 8 bytes on heap, initalize to their index */</span> }

  ~Foo() { <span class="hljs-keyword">delete</span>[] data; }
  Foo() : data(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) {}
  Foo(<span class="hljs-keyword">const</span> Foo &amp;other) : <span class="hljs-built_in">size</span>(other.<span class="hljs-built_in">size</span>), data(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[other.<span class="hljs-built_in">size</span>]) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">memcpy</span>(data, other.data, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * other.<span class="hljs-built_in">size</span>);
  }
  Foo &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Foo &amp;other) { <span class="hljs-comment">/* ...similar to the copy constructor */</span> }

  <span class="hljs-comment">// assume we don't have move semantics.</span>
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">take_foo</span><span class="hljs-params">(Movable&lt;Foo&gt; &amp;foo1)</span> </span>{
  Movable&lt;Foo&gt; foo2;
  foo1.destructive_move(foo2);      <span class="hljs-comment">// move wfoo to foo1</span>
  foo2-&gt;report(<span class="hljs-string">"foo2 in take_foo"</span>); <span class="hljs-comment">// pointer still points to the same place</span>
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{                             <span class="hljs-comment">// 0</span>
  Movable&lt;Foo&gt; foo;                          <span class="hljs-comment">// 1 --+</span>
  foo-&gt;fill_8();                             <span class="hljs-comment">// 2   |</span>
  foo-&gt;report(<span class="hljs-string">"foo in main"</span>);                <span class="hljs-comment">// 4 foo is destructively moved.</span>
  take_foo(foo);                             <span class="hljs-comment">// 3 --+</span>
  foo-&gt;report(<span class="hljs-string">"foo in main"</span>);                <span class="hljs-comment">// 4 Assertion Fail!</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                                  <span class="hljs-comment">// 6</span>
}
</code></pre>
<p>Output</p>
<pre><code>[reporting from foo in main] < 1 2 3 4 5 6 7 8 >
  | [calling destructive_move]
  | [Foo::~Foo()]
  | [reporting from foo2 in take_foo] < 1 2 3 4 5 6 7 8 >
  | [END of take_foo]
  | [Foo::~Foo()]
a.out: moveable.cc:23: T* Movable<T, Args>::operator->() [with T = Foo; Args = {}]: Assertion `not_moved && "access moved object"' failed.
fish: Job 1, './a.out' terminated by signal SIGABRT (Abort)
</code></pre>
<h5>Exception safty</h5>
<h5>Self referential struct</h5>
<h3>Move from state</h3>
<h3>Historical remark</h3>
<h3>How to handle move in C++</h3>
<h3>Conclusion</h3>
