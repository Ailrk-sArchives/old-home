<h2>C++ Template as A Langauge</h2>
<br/>
<p>Templates was added to C++ in it's third release (1991) to support parametric polymorphism, and it was soon be discovered to be much more powerful then it's original design goal. It was proven to be <a href="https://rtraba.files.wordpress.com/2015/05/cppturing.pdf">turning complete</a>, although you cannot directly perform IO with it, technically you can do any other computations with just templates and template specializations. The earliest recorded template abuse I could find was <a href="http://www.erwin-unruh.de/primorig.html">this little program</a> written by Erwin Unruh in 1994 to calculate prime at compile time. Ever since then, C++ templates have became a powerful tool not only enpowering generic programming and meta programming techniques, but also being an ideal tool for recreational programming purpose :p.</p>
<p>I find the descrption &quot;turning complete&quot; a bit unsatisfied. I mean sure you can encode some turing machines and watch the compiler move tapes, or you can implement a <a href="http://matt.might.net/articles/c++-template-meta-programming-with-lambda-calculus/">sicp style interpreter</a>, which itself is turning complete. But I want to use C++ templates to do some real programming. I was imagining a full lambda calculus based functional programming langauge argumented with useful libraries, maybe in monadic style or cps style to make it actually usable for relatively big projects. Apparently this idea has already been explored 7 years ago in <a href="http://www.tnkcs.inf.elte.hu/vedes/sinkovics_abel_ertekezes.pdf">this</a> dissertation. The paper has a comprehensive discussion about how to do functional style programming with C++ templates. Following it's lead, I implemented my own version. Here is a little snippet to demonstrate the effect:</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"tml.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
declare(x); declare(y); declare(z);

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> N&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fact</span>
    :</span> if_&lt;apply&lt;less, N, int_&lt;<span class="hljs-number">1</span>&gt;&gt;,
          int_&lt;<span class="hljs-number">1</span>&gt;,
          apply&lt;times,
                fact&lt;
                    apply&lt;minus,
                          N,
                          int_&lt;<span class="hljs-number">1</span>&gt;&gt;&gt;,
                N&gt;
          &gt; {};

<span class="hljs-keyword">using</span> func =
    lambda&lt;x, y&gt;::<span class="hljs-built_in">begin</span>&lt;
        let&lt;z, int_&lt;<span class="hljs-number">2</span>&gt;,
            in&lt;fact&lt;
                apply&lt;plus,
                      apply&lt;plus, x, y&gt;,
                      apply&lt;times, z, z&gt;
                      &gt;&gt;&gt;&gt;&gt;;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"print it: "</span>
              &lt;&lt; apply&lt;func, int_&lt;<span class="hljs-number">3</span>&gt;, int_&lt;<span class="hljs-number">4</span>&gt;&gt;::value
              &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// $ print it: 3628800</span>
</code></pre>
<p>This example shows some basic features like let binding, lambda, and currying. Later we will add data types with monadic interfaces like maybe type and list type. When I was implementing it I found a lot of topics for implementing a programming language applies here as well. For example, you need specify to what is considered as a value, what comprises an expression, and what does it mean to evaluate something, all in a C++ template setting.</p>
<h3>Mechanisms</h3>
<p>Before we jump into the details, let's refresh the mechanisms that makes C++ templates turing complete. First we know template is completely a compile time concept, they parameterize a body of declaration with a template variable, much like how functions parameterize a body of code. The difference is function takes values as parameters, but templates take types. We pay particular interest in class temlate, because one can think a class template as a mapping from a type to another type:</p>
<pre><code class="language-C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> A&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">add_const_reference</span>{</span>
  <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">const</span> A&amp;;
};
</code></pre>
<p>If we substitute A with <code>int</code>, the example above will generate a full specialization of type <code>add_const_reference&lt;A&gt;</code> when it's applied with a concrete type. We can think the fully specialized version as a thunk, to evaluate it, will access it's <code>type</code> member alias as <code>add_const_reference&lt;int&gt;::type</code>. Reflecting to the compilation process, this means the type <code>const int &amp;</code> will not be accessed.</p>
<h3>Evaluation Strategy</h3>
<h3>Values</h3>
<h3>Let Binding</h3>
<h3>Calling conventions.</h3>
<h3>Lambda!</h3>
<h3>Typeclass default implementations</h3>
<h3>Monads</h3>
<h3>Make it a library</h3>
<p>// TODO unfinished 2021-04-07</p>
