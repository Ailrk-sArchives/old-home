<h1>Report on racket</h1>
<pre><code class="language-lisp">#lang typed/racket
(<span class="hljs-name">require</span> (<span class="hljs-name">for-syntax</span> racket/match))
(<span class="hljs-name">require</span> (<span class="hljs-name">for-syntax</span> racket/syntax))

<span class="hljs-comment">; --------------------------------------------</span>
<span class="hljs-comment">; Report on A quick overview of racket</span>
<span class="hljs-comment">; This report is not based on one particular paper, but rather a conclusion of</span>
<span class="hljs-comment">; multiple sources.</span>
<span class="hljs-comment">; --------------------------------------------</span>

<span class="hljs-comment">; --------------------------------------------</span>
<span class="hljs-comment">; Basics</span>
<span class="hljs-comment">; --------------------------------------------</span>
<span class="hljs-comment">; Boolean &amp; conditions</span>
<span class="hljs-comment">; Use square bracket is more friendly to color blind people than</span>
<span class="hljs-comment">; rainbow bracketes :3</span>
(: condition : Integer -&gt; (<span class="hljs-name">U</span> Symbol Void)) <span class="hljs-comment">; U is Sum type</span>
(<span class="hljs-name">define</span> (<span class="hljs-name">condition</span> n)
  (<span class="hljs-name">if</span> (<span class="hljs-name">&lt;</span> n <span class="hljs-number">50</span>)
    (<span class="hljs-name">if</span> (<span class="hljs-name">=</span> n <span class="hljs-number">20</span>) 'eq20
      (<span class="hljs-name">cond</span> [(<span class="hljs-name">=</span> n <span class="hljs-number">30</span>) 'eq30]  <span class="hljs-comment">; idiomatic scheme use [] to differentiate</span>
            [(<span class="hljs-name">=</span> n <span class="hljs-number">40</span>) 'eq40]  <span class="hljs-comment">; bracket.</span>
            [(<span class="hljs-name">or</span> (<span class="hljs-name">=</span> n <span class="hljs-number">44</span>) (<span class="hljs-name">=</span> n <span class="hljs-number">45</span>)) 'eq44or45]
            [else (<span class="hljs-name">case</span> n
                    [(<span class="hljs-number">1</span>) 'eq1]
                    [(<span class="hljs-number">2</span>) 'eq2]
                    [(<span class="hljs-number">3</span>) 'eq3]
                    [else (<span class="hljs-name">match</span> n  <span class="hljs-comment">; you also have pattern matching</span>
                            [<span class="hljs-number">4</span> 'eq4]
                            [<span class="hljs-number">5</span> 'eq5]
                            [_ (<span class="hljs-name">when</span> (<span class="hljs-name">=</span> n <span class="hljs-number">9</span>) 'eq9)])])]))
    'gt50)) <span class="hljs-comment">; Symbol</span>

<span class="hljs-comment">; --------------------------------------------</span>
<span class="hljs-comment">; list</span>
<span class="hljs-comment">; --------------------------------------------</span>
(: list-fun (<span class="hljs-name">Listof</span> (<span class="hljs-name">U</span> Symbol Number (<span class="hljs-name">Listof</span> Any))))
(<span class="hljs-name">define</span> list-fun
  ((<span class="hljs-name">lambda</span> ()
     (<span class="hljs-name">let*</span> ([x <span class="hljs-number">45</span>]   <span class="hljs-comment">; binding in racket</span>
           [y <span class="hljs-number">55</span>]
           [list1 (<span class="hljs-name">list</span> 'a x y)] <span class="hljs-comment">; with list constructor</span>
           [list2 '(x y)]  <span class="hljs-comment">; make datum with quote</span>
           [listss '((<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) (a b c))]) <span class="hljs-comment">; naming convention. s for nested level</span>
       (<span class="hljs-name">append</span> listss list2 list1)))))

<span class="hljs-comment">; --------------------------------------------</span>
<span class="hljs-comment">; quasiquote</span>
<span class="hljs-comment">; --------------------------------------------</span>
<span class="hljs-comment">; You have list and quote. between this two is quasiquote</span>
<span class="hljs-comment">; you can make a quasiquote with (`) and unquote a value with (,) prefix</span>
<span class="hljs-comment">; In this case you inject x=10 into the quasiquote</span>
(: quasi (<span class="hljs-name">-&gt;*</span> (<span class="hljs-name">#</span><span class="hljs-symbol">:size</span> Integer) (<span class="hljs-name">Listof</span> Number)))
(<span class="hljs-name">define</span> (<span class="hljs-name">quasi</span> #<span class="hljs-symbol">:size</span> n)
  (: stack (<span class="hljs-name">-&gt;</span> Integer (<span class="hljs-name">Listof</span> Integer)))
  (<span class="hljs-name">define</span> (<span class="hljs-name">stack</span> n)
    (<span class="hljs-name">case</span> n
      [(<span class="hljs-name">&lt;=</span> n <span class="hljs-number">0</span>) '()]
      [else (<span class="hljs-name">cons</span> n (<span class="hljs-name">stack</span> (<span class="hljs-name">-</span> n <span class="hljs-number">1</span>)))]))
  (<span class="hljs-name">let</span> ([x <span class="hljs-number">10</span>]
        [xs (<span class="hljs-name">list</span> <span class="hljs-number">9</span> <span class="hljs-number">9</span> <span class="hljs-number">9</span>)]
        [ys (<span class="hljs-name">stack</span> n)])
    `(<span class="hljs-number">1</span> <span class="hljs-number">2</span> ,x ,@xs ,@ys <span class="hljs-number">3</span>)))  <span class="hljs-comment">; @ spread list into the quote (unquote splicing)</span>

<span class="hljs-comment">; --------------------------------------------</span>
<span class="hljs-comment">; Module, contract and mutation</span>
<span class="hljs-comment">; --------------------------------------------</span>
<span class="hljs-comment">; You can define multiple modules in the same file.</span>
<span class="hljs-comment">; it's like restricted namespace, you don't define same module in</span>
<span class="hljs-comment">; different files.</span>
<span class="hljs-comment">; Modules are all lazily evaluated.</span>
(<span class="hljs-name">module</span> bank-account racket <span class="hljs-comment">; we are not using typed racket so can use contract</span>
  (<span class="hljs-name">provide</span> (<span class="hljs-name">contract-out</span>    <span class="hljs-comment">; contract impose constraint. like assert.</span>
           [deposit (<span class="hljs-name">-&gt;</span> positive? any)]
           [balance (<span class="hljs-name">-&gt;</span> positive?)]))
  (<span class="hljs-name">define</span> amount <span class="hljs-number">0</span>)
  (<span class="hljs-name">define</span> (<span class="hljs-name">deposit</span> a) (<span class="hljs-name">set!</span> amount (<span class="hljs-name">+</span> amount a)))   <span class="hljs-comment">; mutation with set!</span>
  (<span class="hljs-name">define</span> (<span class="hljs-name">balance</span>) amount))
<span class="hljs-comment">; the need of contract can be eliminated with proper types</span>
<span class="hljs-comment">; this module shows how to require untyped module in typed racket.</span>
(<span class="hljs-name">module</span> use-bank-account typed/racket
  (<span class="hljs-name">provide</span> get-money)
  (<span class="hljs-name">require/typed</span> 'bank-account
                 [deposit (<span class="hljs-name">-&gt;</span> Positive-Integer Void)])
  (: get-money (<span class="hljs-name">-&gt;</span> Void))
  (<span class="hljs-name">define</span> (<span class="hljs-name">get-money</span>)
    (<span class="hljs-name">deposit</span> <span class="hljs-number">5</span>))
  )

<span class="hljs-comment">; --------------------------------------------</span>
<span class="hljs-comment">; Macros</span>
<span class="hljs-comment">; --------------------------------------------</span>
<span class="hljs-comment">; Make dsl easy!</span>
<span class="hljs-comment">; Because lisp syntax is so easy, the code your macro expand to is</span>
<span class="hljs-comment">; just lisp code itself! (instaed of string like in c)</span>
<span class="hljs-comment">; Some examples of macros</span>

<span class="hljs-comment">; ** hygenic macro **</span>
<span class="hljs-comment">; Basic idea is that your macros will not have name conlision with macros</span>
<span class="hljs-comment">; defined by someone else even when they have the same identifier.</span>
<span class="hljs-comment">; To achieve this, when expanding the macro racket macro expender will</span>
<span class="hljs-comment">; "color" the syntax object with the scope they live in.</span>

<span class="hljs-comment">; Basics ;</span>
<span class="hljs-comment">; A ** syntax transformer ** is a function takes syntax and return syntax.</span>
<span class="hljs-comment">; This is an example that ignore the input syntax and transform a string.</span>
<span class="hljs-comment">; the synax is the constructor of syntax object, and you can write the</span>
<span class="hljs-comment">; short hand version #'</span>
(<span class="hljs-name">define-syntax</span> foo
  (<span class="hljs-name">lambda</span> (<span class="hljs-name">stx</span>) (<span class="hljs-name">syntax</span> <span class="hljs-string">"I am foo"</span>)))

<span class="hljs-comment">; Another way Just to show it's the same as function</span>
(<span class="hljs-name">define-syntax</span> (<span class="hljs-name">say-hi</span> stx)
  (<span class="hljs-name">print</span> stx)   <span class="hljs-comment">; print the syntax object (the code.)</span>
  #'(displayln <span class="hljs-string">"\nhi"</span>))

<span class="hljs-comment">; you can define your own syntax</span>
(: stx-1 (<span class="hljs-name">Syntaxof</span> Any))
(<span class="hljs-name">define</span> stx-1 #'(if x (list <span class="hljs-string">"true"</span>) #f))

<span class="hljs-comment">; Some eliminator of syntax type.</span>
(: syntax-stat (<span class="hljs-name">-&gt;</span> (<span class="hljs-name">Syntaxof</span> Any) Void))
(<span class="hljs-name">define</span> (<span class="hljs-name">syntax-stat</span> stx)
  (<span class="hljs-name">display</span> <span class="hljs-string">"Source: "</span>) (<span class="hljs-name">displayln</span> (<span class="hljs-name">syntax-source</span> stx))
  (<span class="hljs-name">display</span> <span class="hljs-string">"Line: "</span>) (<span class="hljs-name">displayln</span> (<span class="hljs-name">syntax-line</span> stx))
  (<span class="hljs-name">display</span> <span class="hljs-string">"Column: "</span>) (<span class="hljs-name">display</span> (<span class="hljs-name">syntax-column</span> stx)))

<span class="hljs-comment">; You can convert syntax to other stuffs</span>
(: syntax-convert (<span class="hljs-name">-&gt;</span> (<span class="hljs-name">Syntaxof</span> Any) (<span class="hljs-name">Values</span> Any Any)))
(<span class="hljs-name">define</span> (<span class="hljs-name">syntax-convert</span> stx)
  (<span class="hljs-name">values</span> (<span class="hljs-name">syntax-&gt;datum</span> stx) (<span class="hljs-name">syntax-e</span> stx)))

<span class="hljs-comment">; ** datum ** is the type to represent s-expression.</span>
<span class="hljs-comment">; cdr is to get rid of 'reverse-me in the syntax</span>
<span class="hljs-comment">; ps: with datum-&gt;syntax you can even make syntax object on the fly (</span>
<span class="hljs-comment">; make syntax object that doesn't exist in the argument stx).</span>
<span class="hljs-comment">; The reason why we need datum-&gt;syntax is to color the synatx object so</span>
<span class="hljs-comment">; so macro system is hygenic.</span>
(<span class="hljs-name">define-syntax</span> (<span class="hljs-name">reverse-me</span> stx)
  (<span class="hljs-name">datum-&gt;syntax</span> stx (<span class="hljs-name">reverse</span> (<span class="hljs-name">cdr</span> (<span class="hljs-name">syntax-&gt;datum</span> stx)))))
(: reverse-me-driver (<span class="hljs-name">Listof</span> Symbol))
<span class="hljs-comment">; this will transform the syntax into (list 'v 'a "1")</span>
(<span class="hljs-name">define</span> reverse-me-driver (<span class="hljs-name">reverse-me</span> 'x 'a 'v list))

<span class="hljs-comment">; if macro example ;</span>
<span class="hljs-comment">; Classic (if) example. This in haskell can be achieve by function</span>
<span class="hljs-comment">; because of the lazy evaluation, but because racket evaluate eagerly,</span>
<span class="hljs-comment">; you need macro to avoid evaluate all parameters together.</span>
(<span class="hljs-name">define-syntax</span> (<span class="hljs-name">new-if</span> stx)
  (<span class="hljs-name">define</span> xs (<span class="hljs-name">syntax-&gt;list</span> stx))
  (<span class="hljs-name">datum-&gt;syntax</span> stx `(cond [,(cadr xs) ,(caddr xs)]
                            [else ,(cadddr xs)])))

<span class="hljs-comment">; new-if version 2 with match. macro code run at compile time, and</span>
<span class="hljs-comment">; there is only racket/base available. To use other functionalities</span>
<span class="hljs-comment">; you need to require with ** for-syntax **. For instance, here we imported</span>
<span class="hljs-comment">; pattern matching.</span>
(<span class="hljs-name">define-syntax</span> (<span class="hljs-name">new-if2</span> stx)
  (<span class="hljs-name">match</span> (<span class="hljs-name">syntax-&gt;list</span> stx)
    [(<span class="hljs-name">list</span> _ condition true-expr false-expr)
     (<span class="hljs-name">datum-&gt;syntax</span> stx `(cond [,condition ,true-expr]
                               [else ,false-expr]))]))

<span class="hljs-comment">; new-if version 3 with syntax case</span>
<span class="hljs-comment">; syntax-case simplified using pattern matching.</span>
<span class="hljs-comment">; Some differences:</span>
<span class="hljs-comment">; 1. you don't need to manually pattern match</span>
<span class="hljs-comment">; 2. you don't need to feed data into quasi quote any more.</span>
(<span class="hljs-name">define-syntax</span> (<span class="hljs-name">new-if3</span> stx)
  (<span class="hljs-name">syntax-case</span> stx ()
    [(<span class="hljs-name">_</span> condition true-expr false-expr)
     #'(cond [condition true-expr] [else false-expr])]))

<span class="hljs-comment">; define-syntax-rule is a short hand for pattern in new-if3</span>
<span class="hljs-comment">; You can just write code in the body, and they will transform into</span>
<span class="hljs-comment">; syntax automatically.</span>
(<span class="hljs-name">define-syntax-rule</span> (<span class="hljs-name">new-if4</span> condition true-expr false-expr)
  (<span class="hljs-name">cond</span> [condition true-expr] [else false-expr]))

<span class="hljs-comment">; hyphen macro Examples ;</span>
<span class="hljs-comment">; (hyphen-define a b (args) body) -&gt; (define (a-b args) body)</span>

<span class="hljs-comment">; ** define-for-syntax ** allows you to define helper functions in</span>
<span class="hljs-comment">; macro. It's accessible at compile time.</span>
(: stitch-name (<span class="hljs-name">-&gt;</span> (<span class="hljs-name">Syntaxof</span> Any) (<span class="hljs-name">Syntaxof</span> Any) Symbol))
(<span class="hljs-name">define-for-syntax</span> (<span class="hljs-name">stitch-name</span> s1 s2)
    (<span class="hljs-name">string-&gt;symbol</span>
      (<span class="hljs-name">format</span> <span class="hljs-string">"~a-~a"</span>
              (<span class="hljs-name">syntax-&gt;datum</span> s1)
              (<span class="hljs-name">syntax-&gt;datum</span> s2))))

<span class="hljs-comment">; use nested syntax-case.</span>
<span class="hljs-comment">;   First, syntax part in `syntax-case` is called template. In our case</span>
<span class="hljs-comment">; the template in the last line is the syntax get outputed.</span>
<span class="hljs-comment">;   Note parameters of `stitch-name` are syntax #'a #'b rather than pattern</span>
<span class="hljs-comment">; matched a and b: we made a b template.</span>
<span class="hljs-comment">;   You can't use a matched pattern outside of a template. But you can make</span>
<span class="hljs-comment">; an ad hoc template by forcibly using syntax of the symbol of the varible.</span>
<span class="hljs-comment">; (use #'a for a, etc)</span>
(<span class="hljs-name">define-syntax</span> (<span class="hljs-name">hyphen-define/1</span> stx)
  (<span class="hljs-name">syntax-case</span> stx ()
    [(<span class="hljs-name">_</span> a b (<span class="hljs-name">args</span> ...) body0 body ...)
     (<span class="hljs-name">syntax-case</span> (<span class="hljs-name">datum-&gt;syntax</span>
                    #'a   <span class="hljs-comment">;</span>
                    (<span class="hljs-name">stitch-name</span> #'a #'b))
       ()
       [name #'(define (name args ...)  body0 body ...)])])) <span class="hljs-comment">; template.</span>

<span class="hljs-comment">; ** with-syntax ** is like syntax-case but chagne the order of parameters.</span>
(<span class="hljs-name">define-syntax</span> (<span class="hljs-name">hyphen-define/2</span> stx)
  (<span class="hljs-name">syntax-case</span> stx ()
    [(<span class="hljs-name">_</span> a b (<span class="hljs-name">args</span> ...) body0 body ...)
     (<span class="hljs-name">with-syntax</span> ([name (<span class="hljs-name">datum-&gt;syntax</span> #'a (<span class="hljs-name">stitch-name</span> #'a #'b))])
       #'(define (name args ...) body0 body ...))]))

<span class="hljs-comment">; ** with-syntax* ** is the self referential version.</span>
(<span class="hljs-name">define-syntax</span> (<span class="hljs-name">foo</span> stx)
  (<span class="hljs-name">syntax-case</span> stx ()
    [(<span class="hljs-name">_</span> a)
     (<span class="hljs-name">with-syntax*</span> ([b #'a]   <span class="hljs-comment">; force to use pattern a in template</span>
                    [c #'b])
                   #'c)]))

<span class="hljs-comment">; short-circuiting or</span>
<span class="hljs-comment">; evaluate a first, stop the evaluation if it's true.</span>
<span class="hljs-comment">; If you want to implement or with function you must evaluate both a and b,</span>
<span class="hljs-comment">; which is not really what you're intended.</span>
(<span class="hljs-name">define-syntax-rule</span> (<span class="hljs-name">or-short-circuit</span> a b) (<span class="hljs-name">if</span> a a b))

<span class="hljs-comment">; a while loop macro ;</span>
(<span class="hljs-name">define-syntax-rule</span> (<span class="hljs-name">while</span> condition body ...)
  (<span class="hljs-name">let</span> loop ()
    (<span class="hljs-name">when</span> condition
      body ...
      (<span class="hljs-name">loop</span>))))

<span class="hljs-comment">; 3. a macro for swap two variables. ;</span>
<span class="hljs-comment">; ! is convention for mutation</span>
(<span class="hljs-name">define-syntax-rule</span> (<span class="hljs-name">swap!</span> x y) <span class="hljs-comment">; macro are hygienic so no name colisions.</span>
  (<span class="hljs-name">let</span> ([tmp x])
    (<span class="hljs-name">set!</span> x y)
    (<span class="hljs-name">set!</span> y tmp)))
<span class="hljs-comment">; actual macro</span>

<span class="hljs-comment">; --------------------------------------------</span>
<span class="hljs-comment">; Types</span>
<span class="hljs-comment">; --------------------------------------------</span>
<span class="hljs-comment">; Typed tree</span>
(<span class="hljs-name">define-type</span> Tree (<span class="hljs-name">U</span> leaf node))
(<span class="hljs-name">struct</span> leaf ([val : Number]))
(<span class="hljs-name">struct</span> node ([left : Tree] [right : Tree]))

(: tree-height (<span class="hljs-name">-&gt;</span> Tree Integer))
(<span class="hljs-name">define</span> (<span class="hljs-name">tree-height</span> <span class="hljs-literal">t</span>)
  (<span class="hljs-name">cond</span> [(<span class="hljs-name">leaf</span>? <span class="hljs-literal">t</span>) <span class="hljs-number">1</span>]
        [else (<span class="hljs-name">max</span> (<span class="hljs-name">+</span> <span class="hljs-number">1</span> (<span class="hljs-name">tree-height</span> (<span class="hljs-name">node-left</span> <span class="hljs-literal">t</span>)))
                   (<span class="hljs-name">+</span> <span class="hljs-number">1</span> (<span class="hljs-name">tree-height</span> (<span class="hljs-name">node-right</span> <span class="hljs-literal">t</span>))))]))

(: tree-sum (<span class="hljs-name">-&gt;</span> Tree Number))
(<span class="hljs-name">define</span> (<span class="hljs-name">tree-sum</span> <span class="hljs-literal">t</span>)
  (<span class="hljs-name">cond</span> [(<span class="hljs-name">leaf</span>? <span class="hljs-literal">t</span>) (<span class="hljs-name">leaf-val</span> <span class="hljs-literal">t</span>)]
        [else (<span class="hljs-name">+</span> (<span class="hljs-name">tree-sum</span> (<span class="hljs-name">node-left</span> <span class="hljs-literal">t</span>))
                 (<span class="hljs-name">tree-sum</span> (<span class="hljs-name">node-right</span> <span class="hljs-literal">t</span>)))]))

<span class="hljs-comment">; Typed maybe</span>
(<span class="hljs-name">struct</span> None ())
(<span class="hljs-name">struct</span> (<span class="hljs-name">a</span>) Some ([v : a]))
(<span class="hljs-name">define-type</span> (<span class="hljs-name">Opt</span> a) (<span class="hljs-name">U</span> None (<span class="hljs-name">Some</span> a)))

(: find (<span class="hljs-name">-&gt;</span> Number (<span class="hljs-name">Listof</span> Number) (<span class="hljs-name">Opt</span> Number)))
(<span class="hljs-name">define</span> (<span class="hljs-name">find</span> v l)
  (<span class="hljs-name">cond</span> [(<span class="hljs-name">null</span>? l) (<span class="hljs-name">None</span>)]
        [(<span class="hljs-name">=</span> v (<span class="hljs-name">car</span> l)) (<span class="hljs-name">Some</span> v)]
        [else (<span class="hljs-name">find</span> v (<span class="hljs-name">cdr</span> l))]))

<span class="hljs-comment">; polymorphic functions</span>
<span class="hljs-comment">; All is the quantifier.</span>
(: list-len (<span class="hljs-name">All</span> (<span class="hljs-name">a</span>) (<span class="hljs-name">-&gt;</span> (<span class="hljs-name">Listof</span> a) Integer)))
(<span class="hljs-name">define</span> (<span class="hljs-name">list-len</span> l)
  (<span class="hljs-name">if</span> (<span class="hljs-name">null</span>? l)
    <span class="hljs-number">0</span>
    (<span class="hljs-name">add1</span> (<span class="hljs-name">list-len</span> (<span class="hljs-name">cdr</span> l)))))

<span class="hljs-comment">; varadic</span>
(: sumNumbers (<span class="hljs-name">-&gt;</span> Number * Number))
(define (sumNumbers . xs)
  (if (null? xs) 0 (+ (car xs) (apply sumNumbers (cdr xs)))))

; --------------------------------------------
; Exceptions
; --------------------------------------------
; racket also has exception system.
; try catch style. Haskell has similar idiom to
; handle context.
(with-handler ([exn:fail? (lambda (exn) 999)])
              (+ 1 "2"))

; handle case when you break while the program is sleeping.
(with-handler ([exn:break? (lambda (exn) "No time")])
              (sleep 3)
              "phew")

; it will catch numeric value get raised, and return it's
; identity
(with-handler ([number? identity])
              (+ 1 (raise 2)))

; --------------------------------------------
; Some common data structures
; --------------------------------------------

; define structs
; struct is a macro, it will automatically generate methods like
; dog? and dog-* (<span class="hljs-name">dog-name</span>, dog-breed) for struct dog.
<span class="hljs-comment">; it's really like haskell record type, even the accessor part.</span>
(<span class="hljs-name">struct</span> dog ([name : String] [breed : String] [age : Positive-Integer]))
<span class="hljs-comment">; hypotheical way of using struct</span>

<span class="hljs-comment">; ** string-append ** is ad hoc concat for a list of string</span>
<span class="hljs-comment">; ** ~a ** is</span>
(: mk-dog-string (<span class="hljs-name">-&gt;</span> dog String))
(<span class="hljs-name">define</span> (<span class="hljs-name">mk-dog-string</span> d)
  (<span class="hljs-name">let*</span> ([name (<span class="hljs-name">dog-name</span> d)]
         [name-tag (~a (<span class="hljs-name">char-upcase</span> (<span class="hljs-name">string-ref</span> name <span class="hljs-number">0</span>)) name)])
    (<span class="hljs-name">string-append</span> <span class="hljs-string">"Dog name: "</span> name-tag <span class="hljs-string">" | "</span>
                   <span class="hljs-string">"Dog breed: "</span> (<span class="hljs-name">dog-breed</span> d) <span class="hljs-string">" | "</span>
                   <span class="hljs-string">"Dog age: "</span> (~a (<span class="hljs-name">dog-age</span> d) <span class="hljs-string">" Years old"</span>))))

<span class="hljs-comment">; To make a mutable struct you need to specify it in the constructor.</span>
(<span class="hljs-name">struct</span> rgba ([r : Integer]
              [g : Integer]
              [b : Integer]
              [a : Integer]) #<span class="hljs-symbol">:mutable</span> #<span class="hljs-symbol">:transparent</span>)

<span class="hljs-comment">; there are some boilerplates that we can potentially eliminate with macro.</span>
(: color-complement! (<span class="hljs-name">-&gt;</span> rgba Void))
(<span class="hljs-name">define</span> (<span class="hljs-name">color-complement!</span> color)
  (: flip (<span class="hljs-name">-&gt;</span> Integer Integer))
  (<span class="hljs-name">define</span> (<span class="hljs-name">flip</span> n)
    (<span class="hljs-name">cond</span> [(<span class="hljs-name">&gt;</span> n <span class="hljs-number">255</span>) <span class="hljs-number">0</span>]
          [else (<span class="hljs-name">-</span> <span class="hljs-number">255</span> n)]))
    (<span class="hljs-name">set-rgba-r!</span> color (<span class="hljs-name">flip</span> (<span class="hljs-name">rgba-r</span> color)))
    (<span class="hljs-name">set-rgba-g!</span> color (<span class="hljs-name">flip</span> (<span class="hljs-name">rgba-g</span> color)))
    (<span class="hljs-name">set-rgba-b!</span> color (<span class="hljs-name">flip</span> (<span class="hljs-name">rgba-b</span> color)))
    (<span class="hljs-name">set-rgba-a!</span> color (<span class="hljs-name">flip</span> (<span class="hljs-name">rgba-a</span> color))))

<span class="hljs-comment">; you also have tings like vector.</span>
<span class="hljs-comment">; typed racket trips here. I can't use any type other than</span>
<span class="hljs-comment">; Vectorof Integer (even Vectorof Any) ...</span>
(: vector-playground (<span class="hljs-name">Vectorof</span> Integer))
(<span class="hljs-name">define</span> vector-playground
  (<span class="hljs-name">let*</span> ([xs (<span class="hljs-name">take</span> '(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span>) <span class="hljs-number">3</span>)]
         [vs-1 (<span class="hljs-name">list-&gt;vector</span> xs)]
         [vs-2 #(<span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">9</span>)]
         [vs-3 (<span class="hljs-name">vector-append</span> vs-1 vs-2)])
    vs-3))

<span class="hljs-comment">; and set $ hash as normal</span>
(: power-set (<span class="hljs-name">All</span> (<span class="hljs-name">a</span>) (<span class="hljs-name">-&gt;</span> (<span class="hljs-name">Setof</span> a) (<span class="hljs-name">Setof</span> (<span class="hljs-name">Setof</span> a)))))
(<span class="hljs-name">define</span> (<span class="hljs-name">power-set</span> xs)
  (<span class="hljs-name">if</span> (<span class="hljs-name">=</span> <span class="hljs-number">0</span> (<span class="hljs-name">set-count</span> xs))
    (<span class="hljs-name">let</span> ([set1 (<span class="hljs-name">inst</span> set a)]
          [set2 (<span class="hljs-name">inst</span> set (<span class="hljs-name">Setof</span> a))])
      (<span class="hljs-name">set2</span> (<span class="hljs-name">set1</span>)))
    (<span class="hljs-name">let</span> ([xs- (<span class="hljs-name">power-set</span> (<span class="hljs-name">set-rest</span> xs))])
      (<span class="hljs-name">set-union</span>
        (<span class="hljs-name">for/set</span> ([e xs-]) (<span class="hljs-name">set-add</span> e (<span class="hljs-name">set-first</span> xs)))
        xs-))))

<span class="hljs-comment">; Also I found this very convinent digraph for data structures.</span>
<span class="hljs-comment">; DATA STRUCTURE   ACCESS       NUMBER     INDICES</span>
<span class="hljs-comment">; List:            sequential   Variable   not used</span>
<span class="hljs-comment">; Struct:          random       Fixed      names</span>
<span class="hljs-comment">; Vector:          random       Fixed      integer</span>
<span class="hljs-comment">; Growable vector: random       Variable   integer</span>
<span class="hljs-comment">; Hash:            random       Variable   hashable</span>
<span class="hljs-comment">; Splay:           random       Variable   non-integer, total order</span>
</code></pre>
