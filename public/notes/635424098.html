<h1>GHC runtime system</h1>
<h4>Overview of jobs rts does</h4>
<ul>
<li>How to raise exception.</li>
<li>How to allocate prim data structure <code>Array#</code></li>
<li>Contains a multi generational gc with copying and compacting strategies</li>
<li>Contains a user space scheduler for haskell threads.</li>
<li>Bytecode interpreter for ghci.</li>
<li>Dynamic linker for loading object code into ghci.</li>
<li>Heap profiling, time profiling, code coverage of haskell code included.</li>
<li>Support for STM</li>
</ul>
<h4>Structure</h4>
<pre><code>                    c code
                     | (HsFFI.h)
================================================================ RTS
    Storage     |              |            |
   Management   |   Scheduler  |  Profiler  | ...
     (GC)       |              |            |
================================================================
                     | (StgRun)
                 compiled haskell
</code></pre>
<h4>Storage</h4>
<p>Besides a muti generational gc, there are some other components helps rts to manege storage.</p>
<h5>Structure of storage management in rts.</h5>
<pre><code>        Haskell code
            |
     GC and other storage services
            |
      Block allocation layer
            |
           OS
</code></pre>
<h5>Layout of heap object</h5>
<h6>Jargons</h6>
<ul>
<li><code>Bottom</code>  represent a computation which never completes successfully.</li>
<li><code>Lifted type</code> is a type that contains bottom (<code>_|_</code>). If a type is unlifed type, it doesn't contain bottom. For example <code>Array</code> is lifted and <code>ByteArray#</code> is unlifted.</li>
<li><code>Boxed type</code> is a pointer point to an heap object. <code>Unboxed type</code> is a value alone like <code>Int#</code></li>
</ul>
<p>Bottom <code>_|_</code> must be a pointer, and when evaluated, it will throw an exception. Unboxed types cannot be lifted since they will never contain bottom.</p>
<h6>Heap object (Closures.h)</h6>
<ul>
<li>All heap objects have the same basic layout.</li>
<li>Heap object consists with header and payload.</li>
<li>Header contains a info pointer</li>
<li>Info pointer point to the info table for the closure.</li>
</ul>
<pre><code>+========+=================+
| Header |    Payload      |
+===|====+=================+
    |      +============+
    +----->| Info Table |
           +============+
           | Entry Code |
                ...
</code></pre>
<pre><code class="language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StgInfoTable</span>* <span class="hljs-title">info</span>;</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> PROFILING</span>
    StgProHeader prof;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
} StgHeader;
</code></pre>
<p><strong>Info table</strong><br>
A info table contains all information the runtime needsto know about the closure.</p>
<pre><code>+=========================+
|        Layout           |  -- layout of payload. GC will use this info
+=========================+
|      Closure Type       |
+=========================+
|      SRT bitmap         |  -- used to support gc of CAFs
+=========================+
|         Code            |
|                         |
</code></pre>
