<h1>Note: Overview of js ecosystem</h1>
<p>Some overview of support for js as a language. Frameworks like React and vue doesn't count as language support since they are stand alone project.</p>
<h2>babel</h2>
<p>Babel is not only a compiler between different verions of javascript today. As a layer before producing runtime code, a lot of compiler technics can be applied at this level. Babel enabled full fledged ast transformation thus more flexible meta programming.</p>
<h5>tooling</h5>
<ol>
<li>babel-cli (the compiler itself)</li>
<li>babel-register</li>
<li>babel-node</li>
<li>babel-core (for code transformation programming)</li>
</ol>
<ul>
<li>transform(code: string, options) (transform code in the string)</li>
<li>transformFile(filename: string, options, db) (transform file)</li>
<li>transformFileSync(filename: string, options)</li>
<li>transformFromAst(ast, code, options)</li>
</ul>
<h5>configuring</h5>
<p>There are two types of things you can config: babel presets and babel plugins. <code>presets</code>, as the name suggests, are predefined babel transform. You have presets like <code>babel-preset-es2015</code> and <code>babel-preset-react</code>. <code>presets</code> are actually pre configured <code>plugins</code>. If you want to make all objects immutable by default you can make a <code>plugin</code> to transform the code to freeze all ojects right after it is initialized. The most common way of configuring babel is through file <code>.babelrc</code>.</p>
<h5>stages of babel</h5>
<pre><code>Parse -> Transform -> Generate
</code></pre>
<p>Parsing and code generation are just standard compiler process; transform is where code transform happen. You work with AST created in the parser part, find and modify  nodes you are interested, then generate code based on the new ast.</p>
<h5>visitor pattern on AST.</h5>
<p>Visitor pattern is used to traversal across AST. Visitor will traversal all nodes in an AST, and only perform operation on some particular ones (maybe based on some predicates act on the node).</p>
<h5>terms:</h5>
<ul>
<li>Path represents the link between two nodes. Path is reactive, thus any modification on the tree will be reflected.</li>
<li>Avoid state for code transformation, because it's very easy to make inconsistent tree. More on <a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#state">here</a></li>
<li>When creating a new scope you give it a path and a path and a parent scope.</li>
<li>Binding are references that are all belong to a particular scope.</li>
</ul>
<h5>some apis</h5>
<ul>
<li><code>babel-parser</code>
<ul>
<li>parse(code) (parse string directly)</li>
<li>parse(code, { sourceType: &quot;module&quot;, plugins: [&quot;jsx&quot;]}) (add babel options)</li>
</ul>
</li>
<li><code>babel-traverse</code> (easy way of writing visitor)
<ul>
<li>traverse(ast, enter(path) { if (path.node.type === &quot;Identifier&quot; &amp;&amp; ..) { do somehting }} )</li>
</ul>
</li>
<li><code>babel-types</code>
<ul>
<li>traverse(ast, enter(path) { if (t.isIdentifier(path.node)) { do somehting }} )</li>
<li>defineType(...) (define type for nodes)</li>
<li>builder(...) (each node gets a builder method)</li>
<li>validator(...) (validate the type of fields for builder)</li>
</ul>
</li>
<li><code>babel-generator</code> (build source map from ast)
<ul>
<li>generate(ast, {}, code)</li>
</ul>
</li>
<li><code>bable-template</code> (quasiquotes)<pre><code class="language-typescript"><span class="hljs-keyword">import</span> template <span class="hljs-keyword">from</span> <span class="hljs-string">'@babel/template'</span>;
<span class="hljs-keyword">import</span> generate <span class="hljs-keyword">from</span> <span class="hljs-string">'@babel/generator'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> t <span class="hljs-keyword">from</span> <span class="hljs-string">'@babel/types'</span>;
<span class="hljs-keyword">const</span> buildRequire = template(<span class="hljs-string">`
  const IMPORT_NAME =  require(SOURCE);
`</span>);
<span class="hljs-keyword">const</span> ast = buildRequire({
  IMPORT_NAME: t.identifier(<span class="hljs-string">"myModule"</span>),
  SOURCE: t.stringLiteral(<span class="hljs-string">"my-module"</span>)
});

<span class="hljs-built_in">console</span>.log(generate(ast).code);
<span class="hljs-keyword">const</span> myModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">"my-module"</span>);
</code></pre>
</li>
</ul>
<p>Quasi quote make things so much better! I hope quasi quotes can have syntax highlight too, but it seem not very viable.</p>
<h5>best practices.</h5>
<p><strong>1</strong>. Create helper builder and checker.<br>
Template can to some extend replace helper builder.</p>
<p><strong>2</strong>. Avoid traversing ast as much as possible<br>
Try to merge visitors whenever possible, and favor manual look up than traverse. It's pretty much the same as doing <code>dom</code>.</p>
<p><strong>3</strong>. Optimizing nested visitors<br>
If there is a nested visitor, it's better to store the visitor in a variable and pass the same object each time. Otherwise each time call the parent visitor the nested visitor will also create the nested visitor, which can be very costly.</p>
<h2>Runtime</h2>
<p>Pretty high level view of v8 internals. Apparently v8 has some major overhual on its internal, today's component works a lot different from what it was in 2017. (Crankshaft to Turbofan and Ignition)</p>
<h5>v8 overview</h5>
<p>Three statges of execution</p>
<ol>
<li>parser generate AST</li>
<li>Interpreter called <code>Ignition</code> will generate bytecode from the AST.</li>
<li>Compiler <code>TurboFan</code> generate graph from bytecode, and replacing  sections of bytecode with optimized machine code.</li>
</ol>
<h5>JIT process</h5>
<p>Interpreter has very little room for optimization because of the lack of information upon execution. But compiling the entire source code takes too long for large code base. Maintaining a good balance is very important for JIT.</p>
<p>When first executing a piece of code, <code>Profiler</code> will run it through interpreter, and makes profiling informations like how often a function is invoked. This will tag different code segments as warm code segments and <code>hotspots</code>. Warm code segments will be compiled by baseline compiler, which compile faster. <code>Hotspots</code> will be compiled by optimized compiler (<code>-O2</code>), it compiles slower, but its more beneficial, since <code>hotspot</code> code get invoked very frequently.</p>
<p>Assumptions are made by optimized compiler when compiling <code>hotspot</code> code. But when those assumptions are invalidated you need <code>deoptimization</code> to discard the optimized code.</p>
<pre><code>(SRC) → ⟨ Parser ⟩
  ⇒ (AST) → ⟨ Interpreter Ignition ⟩ ⇒ (bytecode sequence)
                  |                           ↑
                  ↓ Feedback                  | deoptimization
            ⟨ Compiler TurboFan ⟩ ⇒ (optimized machine code)
</code></pre>
<h5>balance between interpreter and compiler</h5>
<p>Compilation takes time. Storing optimized code also takes time. If a piece of code is interpreted it doesn't have those upfront compiling overhead and memory overhead, but it also lost any opportunities of optimization.</p>
<h5>GC</h5>
<p>V8 use generational mark-and-sweep based garbage collector. Different from traditional generational gc is v8 use incremental marking, which only mark part of the heap for each pause, and continue to mark the next part of the rest from where it stopped in the last pause. This allow shorter pause during execution.</p>
<h5>Compilation pipeline with learning</h5>
<p>Compilation is based on feedbacks collected from profiling.</p>
<h5>hidden class based object layout</h5>
<p>Encode the layout of object. The hidden class might change in runtime if the object's shape is get mutated.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> o = {<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>}
o.y = <span class="hljs-number">2</span>
</code></pre>
<p>At the first line and the second line the hidden class for object o migrates like this</p>
<pre><code>Map M        Map N
------  ->  -------
x: 1          x: 1
              y: 2
</code></pre>
<p>Bot <code>Map M</code> and <code>Map N</code> are kept in the memory, and the arrow is also stored to indicate how the shape of object is migrated. Not the order of adding properties will result as another hidden class, so it is possible that you have two hidden classes for the same type of object.</p>
<h5>Inline caching (IC).</h5>
<p>Repeated call to the same method tend to have the same type of object. If we know the type of object upfont, we don't need to ask for how the object is structured and how do we access it. Inline caching will cache the object's <code>hidden class</code>, and at the next time of the function call it can use the cached information to address object properties directly.<br>
Specifically, after two successful call of a function to objects with the same hidden class, v8 will assume all calls afterwards are calling with the same hidden class, and jump directly to the memory address of a specific property based on the offset of that hidden class.<br>
This assumption will fail if two objects' properties are initialized in different order even if when they have the same type. In that case inline caching will either not performed or fail. In case of failure compiler need to deoptimize which is a very slow process.</p>
<h5>Ignition</h5>
<p>Has a <code>Bytecode Generator</code> which bytecodes into sequence of bytecodes. Bytecode sequences are basic unit of code segments. The interpreter will run those sequence and collect feedbacks for profiling.</p>
<h5>Turbo Fan</h5>
<p>A compiler back end.</p>
<ul>
<li>instruction selection and scheduling.</li>
<li>register allocation.</li>
<li>code gen.</li>
<li>speculative optimization based on feedback collected from interpreter.</li>
<li>architecture specific optimization.</li>
</ul>
<p><code>Hotspot</code> are usually get compiled and optimized here. But compiling itself cost a lot too.</p>
<h5>&quot;morphisms&quot; of inline caching</h5>
<ul>
<li>monomorphic: operations that hidden classes of arguments are always the same</li>
<li>polymorphic: 2-4 different types seen.</li>
<li>megamorphic: more types then polymorphic</li>
</ul>
<p>At particular location of the code, if the object's inline cache is always the same, it's monomorphic. The less types an operation has the easier it is to optimize. V8 stop optimize megamorphic code.</p>
<h5>pointer compression</h5>
<p>Store 32 bit offsets from some base address rather than using full 64 bit address.</p>
<h5>pointer tagging</h5>
<p>In object based languages (js, lisp... whatever only pass around pointers of objects), generally each objecet will have a specific object header (like <code>PyObject_HEAD</code> in python). This is true for even a simple integer, which can be very expensive. It's very likely that the header itself is much bigger than the integer size. Besides that, pointer referenced integers cannot be used to performed fast integer arithmetics, because to access the underline value you need an extra indirection of dereferece.<br>
V8 pointers are folded with tag bits. Tag bit signals either strong or weak pointers to objects in the heap, or a small integer. The value of an integer can be stored directly in the tagged value, thus eliminate extra allocations and indirections.<br>
Modern CPU requires pointers to be aligned to speed up access. If all pointers are aligned by 4, then the last bit must be 0. If it is 1 then it must be a tagged pointer.<br>
Side note: Small integer sometimes written as <code>smi</code>.</p>
<h5>anecdotes</h5>
<p>v8 is based on the StorngTalk VM, which is based on Self VM (a smalltalk dialect), besides that, a lot of v8 people worked on those 2 VMs too. So v8 inherited a lot from smalltalk implementation. Besides all these, Java's HotSpot JVM is also based on StrongTalk VM, so they share a lot of underlying similarities.</p>
<h5>exploit v8</h5>
<ul>
<li>Instantiate objects' properties in the same order.</li>
<li>Avoid dynamically adding property. If possible, instantiating all properties up front.</li>
<li>Run the same method repeatedly is more optimized than run many methods only once.</li>
<li>Try not to have sparse array. When array is too sparse v8 will make it a dictionary.</li>
<li>If a numberic value is bigger than 31 bits (max of tagged pointer), it will be boxed. So try to use 31 bits signed number as much as possible.</li>
</ul>
<h2>JS builtin (by standard)</h2>
<p>Overall of all JS builtin. Js has more builtin than most other languages, everything kinda floating in the global scope. It is probably because of this initial intention as being a scripting language.</p>
<h5>1. values</h5>
<ul>
<li>Infinity</li>
<li>NaN</li>
<li>undefined (Note <code>undefined</code> is a builtin value property, but <code>null</code> is not)</li>
<li>globalThis.</li>
</ul>
<h5>2. functions</h5>
<ul>
<li>eval() (metaprogramming can use it. but even for metaprogramming this is way too filthy)</li>
<li>isFinite()</li>
<li>isNaN()</li>
<li>parseFloat()</li>
<li>parseInt()</li>
<li>encodeURI() (replacing each instance of some chars into escape seq for transfer)</li>
<li>encodeURIComponent()</li>
<li>decodeURI()</li>
<li>decodeURIComponent()</li>
</ul>
<p>Some functions like <code>parseInt</code> really should not be in global namespace.</p>
<h5>3. Objects</h5>
<ul>
<li>Object
<ul>
<li>Object.assign(target, source) (copy to target)</li>
<li>Object.create(obj) (also by copying)</li>
<li>Object.defineProperty(obj, 'pop', val) (like <code>setattr</code> in python)</li>
<li>Object.freeze() (immutable object)</li>
<li>Object.fromEntries(list) (it's like constructor of <code>Map</code> but for <code>Object</code>)</li>
<li>Object.getOwnPropertyDescriptor(obj. prop) (Property descriptor is descriptor in python)</li>
<li>Object.getOwnPropertyNames(obj)</li>
<li><a href="http://Object.is">Object.is</a>(other) (identity check)</li>
<li>Object.isForzen() (check immutability)</li>
<li>Object.setPrototypeOf(obj, prototype) (substitute the prototype.)</li>
</ul>
</li>
<li>Function</li>
<li>Boolean</li>
<li>Symbol (uniqueness)</li>
</ul>
<p>At runtime js only recognize this four objects. These plus primitive can be tested with <code>typeof</code>.<br>
<code>Object</code> is really an unordered hash table.</p>
<h5>4. Erros</h5>
<ul>
<li>Error (Really it should be called runtime error)</li>
<li>AggregateError (Error Burritos. In haskell it can be easily done with Either and applicative)</li>
<li>EvalError (Filthy)</li>
<li>RangeError (IndexOutOfBound?)</li>
<li>ReferenceError (As it called. Dangling pointer)</li>
<li>SyntaxError</li>
<li>TypeError (This is a joke)</li>
<li>URIError (This is way too specific)</li>
</ul>
<h5>5. Numbers</h5>
<ul>
<li>Math (this is a singleton namespace)</li>
<li>BigInt (arbitrary digit integer. The primitive <code>number</code> max at 2^53 -1)</li>
<li>Number (<code>1</code> is <code>double</code>, but <code>1|0</code> will coerce to integer)</li>
<li>Date (11 is Dec !!! I failed multiple times on this)</li>
</ul>
<h5>6. Text processing</h5>
<ul>
<li>String
<ul>
<li>String.raw() (return a string created from a raw template string)</li>
<li>String.fromCharCode(num1 [, ...])</li>
<li>String.fromCodePoint(num1 [, ...])</li>
</ul>
</li>
<li>RegExp</li>
</ul>
<p><strong>1</strong>. What's the difference between CharCode and CodePoint? CharCode is utf-16 and CodePoint is Unicode. Why don't they use a better name for them? No idea.<br>
<strong>2</strong>. RegExp can be constructed by it's syntax sugar or by constructor. I don't thinn regex is special enough to deserve it's own syntax, so I probably use constructed more often.</p>
<h5>7. Indexed Collections</h5>
<ul>
<li>Array (mutable, heterogenous array list)
<ul>
<li>Array.from() (You can not iterate over a <code>IterableIterator</code>, This is your Iterator. HAHA)</li>
<li>Array.isArray()</li>
<li>Array.of() (it's <code>pure</code> for Array Applicative)</li>
<li>Array.prototye.slice() (main function for immutability. You copy rather mutate.)</li>
<li>Array.prototye.fill() (can be handy sometimes)</li>
<li>Array.prototye.forEach() It' map over <code>IO ()</code></li>
</ul>
</li>
<li>Int8Array
<ul>
<li>Int8Array.property.buffer() (return A<code>ArrayBuffer</code>)</li>
</ul>
</li>
<li>UInt8Array</li>
<li>Int8CampedArray (like UInt8Array but value won't overflow but bounded.)</li>
<li>Int16Array</li>
<li>UInt16Array</li>
<li>Int32Array</li>
<li>UInt32Array</li>
<li>Float32Array</li>
<li>Float64Array</li>
<li>BigInt64Array (Why does it needs a <code>BIG</code> prefix when it comes to Int64?)</li>
<li>BitUInt64Array</li>
</ul>
<p>All this besides Array are called <code>TypedArray</code>, which are essentially different views of <code>ArrayBuffer</code>. You have all this fine grinded control over array element but no real standalone Int32 type..</p>
<h5>8. Keyed Collection</h5>
<ul>
<li>Map (<a href="https://wiki.mozilla.org/User:Jorend/Deterministic_hash_tables"><code>Deterministic Hash Table</code></a> ordered by insertion order in iteration)</li>
<li>Set (same implementation as <code>Map</code>)</li>
<li>WeakMap (Like <code>WeakKeyMap</code> in <code>python</code>, avoid memory leak)</li>
<li>WeakSet</li>
</ul>
<p>This is hash table based collection. <code>WeakRef</code> is added to avoid awkward WeakMap work around.</p>
<h5>9. Structured data</h5>
<ul>
<li>ArrayBuffer (fixed length byte array like you do all the time in C. You modify it via view like Typed Array.)</li>
<li>SharedArrayBuffer (Shared Memory. Used for sharing data between workers)</li>
<li>Atomics (namespace for atomic operations)
<ul>
<li>Atomics.add() Atomics.sub() Atomics.and() Atomics.or() Atomics.xor()</li>
<li>Atomics.compareExchange() (same as <code>test exchange</code>)</li>
<li>Atomics.exchange() (simply swap)</li>
<li>Atomics.wait() (unix <code>wait</code>)</li>
<li>Atomics.notfy() (notify waiting on the specifed index of the array)</li>
<li>Atomics.load() Atomics.store()</li>
</ul>
</li>
<li>DataView (Normalize endianness)</li>
<li>JSON
<ul>
<li>JSON.parse(text) (parse into js object)</li>
<li>JSON.stringify(val) (from value to json)</li>
</ul>
</li>
</ul>
<p><strong>1</strong>. Typically how you use <code>ArrayBuffer</code> is to create the buffer with bytes it holds, and create a new <code>TypedArray</code> on top of it to access it's content.</p>
<p><strong>2</strong>. Shared data are based on TypedArray (SharedArrayBuffer). Even load, store are operations to help works with the shared buffer easier.</p>
<p><strong>3</strong>. One thing to notice about JSON is that json has much simpler grammar rule, so it is faster to parse than javascript. So if there are a lot of data initialization, put them in one JSON file rather than javascript source code can improve the parsing performance. (Because of JIT Parsing speed is also an important performance factor of code execution)</p>
<h5>10. Control abstraction objects</h5>
<ul>
<li>Promise (Future. One thing to note is <code>async await</code> sugar works for it. Some static methods comes very handy but few people use them)
<ul>
<li>Promise.all(iter) wait for all promises to resovle or any to be rejected.</li>
<li>Promise.any(iter) negation of <code>all</code></li>
<li>Promise.race(iter) just return the value of the first resolved promise.</li>
<li>Promise.resolve(value) <code>pure</code> for promise</li>
<li>Promise.reject(reason) <code>pure</code> for promise error</li>
</ul>
</li>
<li>Generator (Just like python generator)
<ul>
<li>Generator.prototype.next()</li>
<li>Generator.prototype.return()</li>
<li>Generator.prototype.throw()</li>
</ul>
</li>
<li>GeneratorFunction (type for <code>function*(){}</code>)</li>
<li>AsyncFunction (type for <code>async function(){}</code>)</li>
</ul>
<p><strong>1</strong>. Promise chaining style is really like monad sequencing...</p>
<p><strong>2</strong>. Generator are good for making lazy data structure.</p>
<p><strong>3</strong>. Async function is sugar.</p>
<h5>11. Reflection</h5>
<ul>
<li>Reflect (yet another namespace object, provides some interface to do runtime reflection)
<ul>
<li>Reflect.has(val, prop)</li>
<li>Reflect.ownKeys(val)</li>
<li>etc ...</li>
</ul>
</li>
<li>Proxy (target and handler)<br>
Proxy is kinda like overwrite python descriptor. But rather override the default behavior here you make a new interaface on top of the original object.</li>
</ul>
