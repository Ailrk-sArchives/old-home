<h1>Some mixin.</h1>
<p>Today do some oop. ewww.</p>
<h2>Mixin</h2>
<h4>Mixin as composable subclass</h4>
<p>Each mixin is a partially defined subclass that can be applied to a superclass to compose a full implementation.</p>
<h4>Lingo for mixins</h4>
<ul>
<li><code>Mixin definition</code>: Definition of the mixin class itself.</li>
<li><code>Mixin application</code>: Application of mixin subclasses, which produces a new superclass.</li>
</ul>
<p>Compare with traditional subclassing, mixin definitions doesn't have a fixed superclass, so they are free to to be composed to form <code>mixin application</code>.</p>
<h4>Hypothetical example</h4>
<p>If typescript support mixin, the syntax can be:</p>
<pre><code class="language-typescript"><span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> A <span class="hljs-keyword">with</span> M {}
</code></pre>
<p>where the superclass is A-with-M rather than A. A-with-M is the Mixin application. The inheritance process is <code>Top -&gt; A -&gt; A with M -&gt; B</code></p>
<h4>Isn't it similar to trait or typeclass?</h4>
<p>No. The naming is very chaotic. Some people refer trait as mixin, but in rust trait is typeclass.</p>
<h4>What's the difference?</h4>
<p><strong>1</strong> Typeclass provides type constrains, while mixin have no impact on type system except the <code>minxin application</code> part.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- typeclass serves as type constraints</span>
<span class="hljs-comment">-- By implementing Eq you not only have the definition of (==),</span>
<span class="hljs-comment">-- but also a notion to restrict the range the type parameter can take.</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Val</span> = <span class="hljs-type">Val</span> a</span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> (<span class="hljs-type">Eq</span> <span class="hljs-title">a</span>) =&gt; <span class="hljs-type">Val</span> a <span class="hljs-keyword">where</span></span>
    (<span class="hljs-type">Val</span> a) == (<span class="hljs-type">Val</span> b) = a == b
<span class="hljs-title">foo</span> :: (<span class="hljs-type">Eq</span> a) =&gt; a -&gt; a -&gt; boolean
</code></pre>
<pre><code class="language-typescript"><span class="hljs-comment">// Eq mixin relies on the existence of `value` property</span>
<span class="hljs-keyword">class</span> Eq {
    <span class="hljs-keyword">declare</span> <span class="hljs-keyword">public</span> id: <span class="hljs-built_in">number</span>;
    eq(other: Eq) {
        <span class="hljs-keyword">this</span>.id == other.id;
    }
}
<span class="hljs-keyword">class</span> A { <span class="hljs-keyword">public</span> value: <span class="hljs-built_in">string</span> = <span class="hljs-string">""</span>; }
<span class="hljs-keyword">interface</span> A <span class="hljs-keyword">extends</span> Eq {};
applyMixin(A, [Eq]);
</code></pre>
<p><strong>2</strong> typeclass can achieve ad hoc polymorphism by providing implementation for different type, while mixin is not polymorphic.</p>
<pre><code class="language-haskell"><span class="hljs-comment">-- similar to function overloading, here (==) is overloaded</span>
<span class="hljs-comment">-- with different implementations for Val and Lue.</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Val</span> a = <span class="hljs-type">Val</span> a</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Lue</span> a = <span class="hljs-type">Lue</span> a</span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> (<span class="hljs-type">Eq</span> <span class="hljs-title">a</span>) =&gt; <span class="hljs-type">Val</span> a <span class="hljs-keyword">where</span></span>
    (<span class="hljs-type">Val</span> a) == (<span class="hljs-type">Val</span> b) = a == b
<span class="hljs-class"><span class="hljs-keyword">instance</span> (<span class="hljs-type">Eq</span> <span class="hljs-title">a</span>) =&gt; <span class="hljs-type">Lue</span> a <span class="hljs-keyword">where</span></span>
    (<span class="hljs-type">Lue</span> a) == (<span class="hljs-type">Lue</span> b) = a != b
</code></pre>
<p>In contrast, mixin only have one implementation. Implementation of typeclass is based on the pair between typeclass and type while for mixin implementation is based on the definition of mixin itself.</p>
<p><strong>3</strong> typeclass has no concept of inheritance, while mixin is a way to insert class definition into an inheritance hierarchy.</p>
<p>Mixin class will eventually be applied and merged into an inheritance tree, while typeclass have no idea of inheritance what so ever. Superclass and subclass in typeclass is another way of saying you must provide a instance of some typeclasses in order to implement this class.</p>
<h4>What's the difference between abstract class default implementation?</h4>
<p>Abstract class + default implementation is still normal subclassing, which on subclass has one fixed superclass.</p>
<p>Mixin allows you to have multiple mixin definitions composed to make a different superclass to inherit from.</p>
<h4>How do I feel about it?</h4>
<p>It's not a real abstraction technic, it just builds a concrete implementation from smaller concrete implementations.</p>
<h2>Declaration merging</h2>
<h4>Different types of declarations</h4>
<p>Based on where the declaration exists, declarations in typescript can be roughly classified into three categories. Differences are subtle but it gives a sense of the boundary between compile time and runtime constructs.</p>
<ul>
<li>Namespace-creating declaration. Declare names that are accessible with dot notation. (<code>var name; (()=&gt;{val.foo=1})(val);</code>)</li>
<li>Type-creating declaration. Declare type.</li>
<li>Value-creating declaration. Simple name binding that is visible in the output code.</li>
</ul>
<h4>Declaration type table (just get it from ts handbook)</h4>
<table>
<thead>
<tr>
<th>Declaration</th>
<th>Namespace</th>
<th>Type</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Namespace</td>
<td>X</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>Class</td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Enum</td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Interface</td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Type Alias</td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Function</td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>Variable</td>
<td></td>
<td></td>
<td>X</td>
</tr>
</tbody>
</table>
<h4>Interface declaration merging</h4>
<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> Foo {foo(a: <span class="hljs-built_in">string</span>);}
<span class="hljs-keyword">interface</span> Foo {foo(a: <span class="hljs-built_in">number</span>);}
</code></pre>
<h4>Namespace is flexible for declaration merging</h4>
<p><strong>1</strong> Namespace with namespace, works as c++.</p>
<pre><code class="language-typescript">namspace A {
    foo: <span class="hljs-built_in">string</span> = <span class="hljs-number">10</span>;
}
<span class="hljs-comment">// will compile to</span>
<span class="hljs-keyword">var</span> A;
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) </span>{
    A.foo = <span class="hljs-number">10</span>;
})(A || (A = {}))
</code></pre>
<p><strong>2</strong> Namespace with enum to add static function for it.<br>
<strong>3</strong> Namespace with class allows to define internal class.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">class</span> Album {
    label: Album.AlbumLabel;
}
<span class="hljs-keyword">namespace</span> Album {
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AlbumLabel {}
}
</code></pre>
<p><strong>4</strong> Namespace with function. You can extend the function with extra members. It essentially gives function <code>static</code> in c and still type check.</p>
<h2>ts enum</h2>
<h4>How does typescript compile enum?</h4>
<pre><code class="language-typescript"><span class="hljs-keyword">enum</span> E { A, B };
</code></pre>
<p>This will be compiled to</p>
<pre><code class="language-typescript"><span class="hljs-comment">// essentially how they compile namespace, but will different logic.</span>
<span class="hljs-comment">// note assignment in js will return the rhs value. It's really weird.</span>
<span class="hljs-comment">// It basically creates a circular key reference each other.</span>
<span class="hljs-keyword">var</span> E; (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">E</span>) </span>{E[E[<span class="hljs-string">"A"</span>]] = <span class="hljs-number">0</span> = <span class="hljs-string">"A"</span>; E[E[<span class="hljs-string">"B"</span>]] = <span class="hljs-number">1</span> = <span class="hljs-string">"B"</span>;} (E || E = {}))
</code></pre>
<p>In addition, there is a difference between const and non const enum when they are addressed in code. For const enum some optimization can be performed (get inlined).</p>
<pre><code class="language-typescript"><span class="hljs-keyword">enum</span> E { A, B }; <span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> CE { A, B };
<span class="hljs-keyword">let</span> a = E.A;    <span class="hljs-comment">// =&gt; compile to let a = E.A;</span>
<span class="hljs-keyword">let</span> b = CE.A;   <span class="hljs-comment">// =&gt; compile to let b = 0;</span>
</code></pre>
<h2>today's random</h2>
<h3>Dynamic scoping vs lexical scoping and this in js.</h3>
<p>When I was learning js I conclude <code>this</code> is an example of dynamic scoping, but it's not quite right. <code>this</code> is just a sugar for passing a implicit parameter. But because the binding mechanism depends on how the function is called, it's really similar to dynamic scoping.</p>
<h4>Dynamic scope</h4>
<p>Scope is determined by call stack at runtime.</p>
<h4>Lexical scope</h4>
<p>Scope is determined at compile time based on the declaration.</p>
<h4>This in js</h4>
<p>For a normal <code>function</code> what <code>this</code> refers to depends on where the invocation heppends. It's like self in python and rust, <code>:</code> in lua, nothing special about it really.</p>
<h4>Randome ECMAScript spec for <code>this</code></h4>
<p>Implementation of <code>this</code> is specified by ECMAScript spec. It defines <code>GetThisEnvironment()</code>, which is a function to finds the environment instance that currently supplies the binding of <code>this</code>.</p>
<h4><code>this</code> in Function context.</h4>
<p>Arrow function doesn't have it's own this, but rather inherit <code>this</code> from the parent's one.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">const</span> obj = { f: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>; }
<span class="hljs-keyword">const</span> f1 = obj.f;
obj.f() === f1();
</code></pre>
<p>value of <code>this</code> in regular function depends on how it is calle. It will be undefined in <code>strict mode</code>.</p>
<pre><code>const obj = { f: function() {return this;} };
const f1 = obj.f;
obj.f() !== f1;
// obj.f() return obj, f1 return global in non strict mode, and undefined in strict mode.
</code></pre>
<p>You can rebind <code>this</code> of a regular function.</p>
<pre><code>const obj = { f: function() {return this;} };
const f1 = obj.f;
f1.bind(obj);
obj.f() === f1; // no problem
</code></pre>
<h4><code>this</code> in  class context.</h4>
<p>In base class <code>this</code> behaves exactly the same as function, because under the hood class can be desugared into funcitons. All non-static methods will be added to the prototype of <code>this.</code></p>
<p>In derived class, there is no default <code>this</code> binding. By calling <code>super()</code> <code>this</code> will be bind to base class. The bindinng process is similar to <code>this = new Base();</code>. This is why any reference of <code>this</code> before <code>super()</code> is invalid.</p>
<h4><code>Function</code> apis works with <code>this</code></h4>
<p>Assume this code exists.</p>
<pre><code class="language-typescript">funcitons add(c, d) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a + <span class="hljs-keyword">this</span>.b + c + d;
}
<span class="hljs-keyword">let</span> o = {a: <span class="hljs-number">1</span>, b: <span class="hljs-number">3</span>};
</code></pre>
<h5>call and apply</h5>
<p><code>o</code> defined above will become this in the following invocation.</p>
<pre><code class="language-typescript">add.call(o, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>);
add.apply(o, [<span class="hljs-number">5</span>, <span class="hljs-number">7</span>]);
</code></pre>
<h5>bind</h5>
<p><code>add1</code> below will be a funciton with <code>oo</code> as it's <code>this</code>.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">const</span> oo = {a: <span class="hljs-number">10</span>, b: <span class="hljs-number">20</span>};
<span class="hljs-keyword">const</span> add1 = add.bind(oo);
</code></pre>
