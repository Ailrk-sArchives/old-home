<h1>ST, Zipper.</h1>
<h2>ST monad</h2>
<p><code>STRef</code> is a more generic form of <code>IORef</code> that allows you to have mutable reference. <code>ST s a</code> is a <code>state</code> like monadic interface helps you to use <code>STRef</code>. <code>runST :: (forall s. ST s a) -&gt; a</code> is the function to execute a <code>ST</code> computation, and it use <code>rank 2 type</code> to enforce the mutable reference is always to each <code>runST</code>, so that the side effect can only happen inside the <code>runST</code>, and externally behave like a pure function.</p>
<h4>A very cool implementation of quick sort with in place mutation in haskell</h4>
<p>Without mutation, to write a quick sort is actually easier. Like this:</p>
<pre><code class="language-haskell"><span class="hljs-title">quickSort1</span> :: (<span class="hljs-type">Ord</span>) =&gt; [a] -&gt; [a]
<span class="hljs-title">quickSort1</span> [] = []
<span class="hljs-title">quickSort1</span> (x:xs) = left ++ [x] ++ right
  <span class="hljs-keyword">where</span>
    left = quickSort1 $ filter (&lt;=x) xs
    right = quickSort1 $ filter (&gt;x) xs
</code></pre>
<p>This version looks very neat, just doesn't perform very well. Because everything is immutable, so the runtime will create a new list in each iteration. Although the gc process is not too bad for immutable data, it is still not idea compare with a in place mutation.</p>
<p>With <code>STRef</code> and <code>ST s a</code> monad we can have inplace mutation while providing a pure interface. This allows us to implement algorithms that are more efficient with mutation.</p>
<h5>Implementation</h5>
<p><code>STRef</code> and <code>STArray</code> are basical notion of dealing with mutation in haskell, and <code>ST s a</code> monad provides a monadic environment for the mutation to happen.<br>
Expr</p>
<h6>Swap</h6>
<p>The swap logic can just be written in the say way as you would write in an imperative language.</p>
<pre><code class="language-haskell"><span class="hljs-title">swap</span> :: <span class="hljs-type">STArray</span> s <span class="hljs-type">Int</span> a -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">ST</span> s ()
<span class="hljs-title">swap</span> arr i j = <span class="hljs-keyword">do</span>
    a &lt;- readArray arr i
    b &lt;- readArray arr j
    writeArray arr i b
    writeArray arr j a
</code></pre>
<h6>Do one partition</h6>
<p><code>lift $ readArray arr i</code> makes an action with type <code>StateT Int (St s) a</code>, which can be shoved into the next monadic function. The same thing happens in <code>lift $ swap arr i pivotIdx</code>. See how <code>ST s</code> is used like <code>IO</code>, the <code>s</code> part in the type is actually a phantom type to constrain the underline scope of <code>STRef</code>.</p>
<pre><code class="language-haskell"><span class="hljs-title">partition'</span> ::
    (<span class="hljs-type">Ord</span> a) =&gt; <span class="hljs-type">STArray</span> s <span class="hljs-type">Int</span> a -&gt; a -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">StateT</span> <span class="hljs-type">Int</span> (<span class="hljs-type">ST</span> s) ()
<span class="hljs-title">partition'</span> arr pivot i = <span class="hljs-keyword">do</span>
    pivotIdx &lt;- get
    this &lt;- lift $ readArray arr i
    when (this &lt; pivot) $ <span class="hljs-keyword">do</span>
        lift $ swap arr i pivotIdx
        put (pivotIdx + <span class="hljs-number">1</span>)
</code></pre>
<h6>Partition</h6>
<p>Set piovt like.</p>
<p>Note <code>execStateT :: (Monad m) =&gt; StateT s m a -&gt; s -&gt; m s</code> execute the state and get the <code>s</code> back. <code>pivotIdx0</code> is the inital state we provide.</p>
<p>Note <code>mapM :: (Monad m) =&gt; (a -&gt; m b) -&gt; t a -&gt; m t b</code> collect the result automatically, it works like <code>sequence . fmap</code> act on monadic function.</p>
<pre><code class="language-haskell"><span class="hljs-title">partition</span> :: (<span class="hljs-type">Ord</span> a) =&gt; <span class="hljs-type">STArray</span> s <span class="hljs-type">Int</span> a -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">ST</span> s <span class="hljs-type">Int</span>
<span class="hljs-title">partition</span> arr start end = <span class="hljs-keyword">do</span>
    pivot &lt;- readArray arr start
    <span class="hljs-keyword">let</span> pivotIdx0 = start + <span class="hljs-number">1</span>
    finalPivotIndx &lt;-
        execStateT
            (<span class="hljs-type">MapM</span> (partition' arr pivot) [(start + <span class="hljs-number">1</span>) .. (end - <span class="hljs-number">1</span>)])
            pivotIdx0
    swap arr start (finalPivotIndx - <span class="hljs-number">1</span>)
    return $ finalPivotIndx - <span class="hljs-number">1</span>
</code></pre>
<h6>A helper</h6>
<p>Perform the recursive partition. Wrap this logic in another function allows us to encapsulate the mutation, and provides a pure interface.</p>
<pre><code class="language-haskell"><span class="hljs-title">helper</span> :: (<span class="hljs-type">Ord</span> a) =&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">STArray</span> s <span class="hljs-type">Int</span> a -&gt; <span class="hljs-type">St</span> s ()
<span class="hljs-title">helper</span> start end stArray = when (start + <span class="hljs-number">1</span> &lt; end) $ <span class="hljs-keyword">do</span>
    pivotIdx &lt;- partition stArray start end
    helper start pivotIdx stArray
    helper (pivotIdx + <span class="hljs-number">1</span>) end stArray
</code></pre>
<h6>Assemble everything</h6>
<p><code>runSTArray</code> perform the action of a <code>ST</code> monad, and return  an immutable <code>Array</code>.</p>
<p>Note <code>thaw</code> here still copy the array, to do a implace thaw you can use <code>unsafeThaw</code></p>
<p>Note <code>bounds</code> give the range of the array.</p>
<pre><code class="language-haskell"><span class="hljs-title">qsort</span> :: (<span class="hljs-type">Ord</span> a) =&gt; <span class="hljs-type">Array</span> <span class="hljs-type">Int</span> a -&gt; <span class="hljs-type">Array</span> <span class="hljs-type">Int</span> a
<span class="hljs-title">qsort</span> arr = runSTArray $ <span class="hljs-keyword">do</span>
    stArray &lt;- thaw arr
    <span class="hljs-keyword">let</span> (min, max) = bounds arr
    helper min (max + <span class="hljs-number">1</span>) stArray
    return stArray
</code></pre>
<h4>ST</h4>
<p>The inplace implementation of quick sort use mutable references based on <code>ST s</code> monad.</p>
<h4>Some utilities from Data.STRef</h4>
<p>These functions look really similiar to those <code>State</code> provides. The difference is <code>State</code> is functional state, but <code>ST</code> is real mutation.</p>
<p>These are all functions exposed by <code>STRef</code>, all other mutable opeartions will build on top of them.</p>
<h5><code>STRef s a</code></h5>
<p>A reference to mutable variable in the state thread <code>s</code>, containing a value of type <code>a</code></p>
<h5><code>newSTRef :: a -&gt; ST s (STRef s a)</code></h5>
<p>Create a new <code>STRef</code> in the current state thread</p>
<h5><code>readSTRef :: STRef s a -&gt; ST s a</code></h5>
<p>Read the value of the <code>STRef</code></p>
<h5><code>writeSTRef :: STRef s a -&gt; a -&gt; ST s ()</code></h5>
<p>Write into the <code>STRef</code></p>
<h5><code>modifySTRef :: STRef s a -&gt; (a -&gt; a) -&gt; ST s ()</code></h5>
<p>Mutate the content of <code>STRef</code>. The function is not applied strictly, so if the value get mutated but is seldomly used, the thunk will accumulate and cause memory leak. <code>modifySTRef'</code> provides strict version of the function.</p>
<p>Note <code>STRef s a</code> has <code>Eq</code> instance to compare the pointer identity.</p>
<pre><code class="language-haskell"><span class="hljs-title">runST</span> $ <span class="hljs-keyword">do</span>
    ref &lt;- newSTRef <span class="hljs-string">"Hello"</span>
    writeSTRef ref (x ++ <span class="hljs-string">" world"</span>)
    readSTRef ref
</code></pre>
<h4>ST monad</h4>
<p><code>data ST s a</code></p>
<h5><code>runST :: (forall s. ST s a) -&gt; a</code></h5>
<p><code>runST</code> uses rank 2 type. value of <code>s</code> in <code>ST</code> is never accessible, it is actually a phantom type.</p>
<h5><code>fixST :: (a -&gt; ST s a) -&gt; ST s a</code></h5>
<h4>Converting ST to IO</h4>
<p><code>stToIO :: ST :: ST RealWorld a -&gt; IO a</code><br>
See <code>ST</code> and <code>IO</code> are pretty much the same. Here the phantom type <code>s</code> of <code>ST</code> is replaced with <code>RealWorld</code>, which gives you an IO...</p>
<p>There is also an similiar <code>ioToST :: IO a -&gt; ST RealWorld a</code>.</p>
<p><code>data RealWorld</code> is a primitive type... It is only used in the type system, as programmer you never touch it.</p>
<h2>Zipper</h2>
<p>Zipper is an idiom for more efficient immutable data modification. Traditinally if you want to modify a node of a immutable binary tree, you need to traverse to the node, and construct a new tree with a new ndoe. If the node is deeply nested, it will be very inefficient. Zipper solve this problem by simply observed the fact that change the root of the node can be very efficient since it is not nested at all, nothing in the path need to be rebuild. So when using a zipper, each time address a value in the tree, it will change the focus to that node, and make the node as the root of the tree. By doing so modification will only involve change of the root node.</p>
<p>For list zipper we can represent like this</p>
<pre><code>(2 1) 3 (4 5 6)
</code></pre>
<p>Where <code>3</code> is the current focus. Note the order of the left part is reversed, it's because if it's implemented as a list, <code>head</code> is far more efficient than <code>tail</code>; and because logically <code>2</code> and <code>3</code> are logically connected, it should be easier to reach <code>2</code>. Reverse the order helps us to do that.</p>
<p>An example is list zipper, which can be defined like this</p>
<pre><code class="language-haskell"><span class="hljs-comment">--          goForward   3</span>
<span class="hljs-comment">--  2   4  ---------&gt;   2</span>
<span class="hljs-comment">--  1 3 5               1 4 5</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ListZipper</span> a = <span class="hljs-type">ListZipper</span> {
    <span class="hljs-title">left</span> :: [<span class="hljs-title">a</span>]
    <span class="hljs-title">focus</span> :: !<span class="hljs-title">a</span>
    <span class="hljs-title">right</span> :: [<span class="hljs-title">a</span>]
} <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>, <span class="hljs-type">Read</span>, <span class="hljs-type">Eq</span>)</span>
</code></pre>
<h5>conclusion</h5>
<p>A way to look at zipper is it is a updateable pure funtional cursor into a data structure. It helps to keep track of element deelpy<br>
nested in the data structure,</p>
<h2>Benefits Immutable data</h2>
<ul>
<li>Easier to reason about</li>
<li>Can be share across thread without worry about data racing.</li>
<li>We can have the old version of the data (modify by copying).</li>
</ul>
