<h1>Formdata fetch</h1>
<h2>Body of a post.</h2>
<p>Four forms to encode data into the body of a post request.</p>
<ul>
<li><code>application/x-www-form-urlencoded</code></li>
<li><code>multipart/form-data</code></li>
<li><code>text/plain</code></li>
<li><code>application/json</code></li>
</ul>
<p>If you are using json to send binary files you need to encode it into base64, while form data support <code>Blob</code> type, so you can append bianry data directly into it. In browser <code>FormData</code> can be helpful to construct a form data. <code>x-www-form-urlencoded</code> is the method to encode key value pairs in the url directly, <code>URLSearchParam</code> can be used to encode key value pairs into linear text form, so you can append it after the url. Plain text is just plain text. It is not unsuual to see people encode binary into base64 with plain text format.</p>
<h2>preflight request with axios.</h2>
<p>Axios try to unify the behavior of requests they send between browser and backend, so if server has some specific CORS setting, your node request will be affected too.</p>
<p>I found node-fetch is much better, I really don't like the way axios wrap the response on top of another layer of <code>AxiosResponse</code>, seems pretty unnecessary.</p>
<h2>fetch</h2>
<p>fetch is the new api used to replace <code>XMLHTTPRequest</code>. It's more avilable than axios, since the browser side already ships it by default.</p>
<h2>Difference between array buffer and blob</h2>
<h4>ArrayBuffer</h4>
<p>Literatly a fat poiter to fixed lenght array. It can only be manipulated via a view on top of it (Int8Array). It's mutable data and as it's name implied it can be used for buffer.</p>
<h4>Blob</h4>
<p>Binary representation of a raw immutable data.</p>
<p>So in the browser everything is very clear, if you want buffer you use <code>ArrayBuffer</code>, if you want immutable binary representation you use <code>Blob</code>. The problem is node doesn't support <code>Blob</code>, instead it has it's own <code>Buffer</code> type.</p>
<h2>Stream and Generator</h2>
<p>In python to work with infinite data the first thing comes in mind is to use a generator. Node support generator now, but there is also this <code>Stream</code> that deeply nested with other part of the standard library, especially <code>fs</code> and <code>http</code>. For instance, you can <code>fs.createReadStream</code> to create a stream on reading a file, and <code>httpServerResponse</code> to create a stream to response large data.</p>
<h4>Sync Stream</h4>
<p>A possible implementation of a stream</p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> {Readable, Writable} <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;

<span class="hljs-comment">// pull based reader, it will read whenever content in</span>
<span class="hljs-comment">// buffer is less than a threshold.</span>
<span class="hljs-keyword">const</span> createCounterReader () =&gt; {
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Readable({
        objectMode: <span class="hljs-literal">true</span>,
        read() {
            count += <span class="hljs-number">1</span>;
            <span class="hljs-keyword">this</span>.push(count);
        }
    })
}

<span class="hljs-comment">//</span>
<span class="hljs-keyword">const</span> logWriter = <span class="hljs-keyword">new</span> Writable({
    objectMode: <span class="hljs-literal">true</span>,
    write: <span class="hljs-function">(<span class="hljs-params">chunk, _, done</span>) =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'writing: '</span>, chunk);
        done();
    }
})

<span class="hljs-comment">// pipe streams</span>
createCounterReader().pipe(logWriter);
<span class="hljs-comment">// this will count number infinitely.</span>
</code></pre>
<p>Readable stream will read multiple items at once to fill it's item, and wait for items to be consumed. Once the buffer is filled the reader will not read anymore. It will then wait for the item to be used by some other streams until buffer is below some threashold.</p>
<h4>Sync Generator</h4>
<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">counter</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        count += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">yield</span> count;
    }
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item of count()) { <span class="hljs-built_in">console</span>.log(item); }
</code></pre>
<h2>npm link and dependency</h2>
<p>You can put the dependency in the package.json while still using <code>npm link</code> linked package. All you need to do is to run <code>npm link &lt;package&gt;</code> again after you do <code>npm install</code>, <code>npm link</code> will overwrite the downloaded version with the linked version.</p>
<p>One catch is to remember update the local package version eachtime you publish the package. It's better to write a script for doing that.</p>
<h2>async catch.</h2>
<p>Two catches that might block.</p>
<h4>Unrelated asynchronous operations</h4>
<pre><code class="language-typescript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">2000</span>);
    })
<span class="hljs-keyword">const</span> p2 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">2000</span>);
    })

<span class="hljs-comment">// normal</span>
(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    p1.then(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> { <span class="hljs-built_in">console</span>.log(a) });
    p2.then(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> { <span class="hljs-built_in">console</span>.local(a) });
})()

<span class="hljs-comment">// double the time</span>
(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> a = <span class="hljs-keyword">await</span> p1(); <span class="hljs-built_in">console</span>.log(a);
    <span class="hljs-keyword">const</span> b = <span class="hljs-keyword">await</span> p2(); <span class="hljs-built_in">console</span>.log(b);
})
</code></pre>
<p>Think await as <code>&gt;&gt;=</code> that blocks (in a async context), so anything after await get executed sequentially. To achieve the same result as the first example, we want to do someting like <code>[p1, p2] &gt;&gt;= ...</code>, to achieve this use <code>Promise.all()</code>.</p>
<pre><code class="language-typescript">(<span class="hljs-keyword">async</span>() =&gt; { <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([p1, p2])})
</code></pre>
<p>This time it doesn't block.</p>
<h4>Series of calls await for an asynchrnous operation</h4>
<p>Await in for loop get things block.</p>
<pre><code class="language-typescript">(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">as</span> = <span class="hljs-keyword">await</span> somePromise();
    <span class="hljs-keyword">for</span> (a of <span class="hljs-keyword">as</span>) {
        <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">await</span> anotherPromise(a);
        <span class="hljs-keyword">do</span> stuff...
    }
})()
</code></pre>
<p>The loop is strictly synchronous and you get zero benefits out of async. The solution is still Promise.all.</p>
<pre><code class="language-typescript">(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> promises = (<span class="hljs-keyword">await</span> somePromise()).map(<span class="hljs-keyword">async</span> a =&gt; {
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> anotherPromise(a));
    });
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(promises);
    <span class="hljs-keyword">do</span> stuff ...
})
</code></pre>
<p>This doesn't block.</p>
