<h1>Typescript moduels, async in react.</h1>
<h2>Modules in typescript</h2>
<h5>1. Modules execute on their own scope</h5>
<p>Like all modern module systems. If all functions are pure then the module is just a namespace. But if there is state, since the module is scoped it can serve as a container, avoiding global state.</p>
<h5>2. ECMAScript</h5>
<p>Any file containing top-level import or export is considered a module. Otherwise the file is treated as a script.</p>
<h5>3. Re-export doesn't import value locally.</h5>
<p>Re-export simply propagate the value to the next import.</p>
<h5>4. Export * from &quot;module&quot;;</h5>
<p>Export everthing. This can be used as top level export.</p>
<h5>5. Import for side effects.</h5>
<p>If a module has no export, import it will simply execute it. It's useful for setting up an environment.</p>
<h5>6. Barrel.</h5>
<p>Re-exporting everything in index.ts.</p>
<h2>async in react.</h2>
<p>Asynchronous requests can cause some problems in react component.</p>
<h5>1. Asynchronous response can arrive after a component is teared down.</h5>
<p>Asynchronous response can arrive after the component is unmounted. This will cause a React's runtime exception, which is an error message. Not a big deal but it can be better.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">const</span> ismounted = useRef&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">true</span>);

useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { ismounted.current = <span class="hljs-literal">false</span>; };
}, []);

useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> f = <span class="hljs-keyword">async</span> () =&gt; { <span class="hljs-keyword">if</span> (ismounted.current) setValue(<span class="hljs-keyword">await</span> ...); }
}, []);
</code></pre>
<h5>2. Race condition</h5>
<p><code>useEffect</code> can depend on some prop, and when the prop update useEffect might send the asynchronous request again before the previous reuqest resolved. If the second request arrive earlier it will cause a race condition. Solution is to cancel the previous request when sending a new request. Or maybe use sequence number?</p>
<h2>Code splitting</h2>
<p>Webpack allows code splitting, which means it bundles your code into chunks, and each chunk and be download asynchronously. This allows to load a fast-to-load minial bundle, and adding more bundle asynchronously after that. So for instance in <code>create-react-app</code>, as long as there are no static files in <code>public</code> folder all codes will eventually be delivered to client side. But with code splitting this can happen in a non blocking manner so the load time doesn't feel so long.</p>
<h2>Link Local npm package</h2>
<p>If you have two local package and one depends on another, you can use <code>npm link</code>. First create a global link in the library that is depended by running <code>npm link</code>, and in the package that depends on the first package run <code>npm link &lt;dependency&gt;</code>.</p>
<h5>caveats</h5>
<p><code>npm link</code> doesn't auto compile. Everytime you changed your dependency you need to manually relink it to global sym links, and link from the main project again.</p>
<h2>Iterator and IterableIterator...</h2>
<h5>Down level iteration for ES5</h5>
<p>An iteration over array or string will be simply compiled to a simple loop, but for a general iterator the compiler will needs to shove an entire implementation of the iterator protocol, which can bloat the code size.</p>
<h2>Promise are not evaluated lazily</h2>
<p>Executor passed into the promise will be called immediately. All the chain calls are just methods to access the result of executor. I am a little bit surprised because I always thought promises are lazily evaluated. But if you think carefully about it there is no special reason for it to be so. Promise is designed to replace callback style asynchronous call, which you typically need to pass a callback to handle the value when it is arrived, and another callback to handle error case. With promise you don't pass these two functions into another async function, but rather wrap the entire async computation in a promise, then use <code>then</code> and <code>catch</code> to pass those callbacks.</p>
<h2>Common pattern type Class&lt;T&gt; = Function &amp; { prototype: T }</h2>
<p>Works like the classical linked list definition. <code>&amp;</code> is use to add new properties to exist type. It's applicable with any types includes built-ins, so it's a good way to extend build-ins without touching oop.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">type</span> LList&lt;T&gt; = T &amp; { next LList&lt;T&gt;};
<span class="hljs-keyword">type</span> Class&lt;T&gt; = <span class="hljs-built_in">Function</span> &amp; {prototype: T};
</code></pre>
<h2>You have abstract class in typescript</h2>
<p>Never know it before.</p>
<h2>typeof at typelevel.</h2>
<p><code>typeof</code> can also be used at type level gives <code>decltype</code> style inference.</p>
<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> {a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>}};
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> b: ReturnType&lt;<span class="hljs-keyword">typeof</span> fn&gt;;
</code></pre>
<p>A special case for <code>typeof</code> on const array literal.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">const</span> data = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">type</span> Data = <span class="hljs-keyword">typeof</span> data[<span class="hljs-built_in">number</span>]; <span class="hljs-comment">// "a" | "b"</span>
</code></pre>
<h2>tsc configs</h2>
<ul>
<li>noEmitOnError (refuse to compile when there is type error)</li>
<li>noImplicitAny</li>
<li>strictNullChecks (is on with <code>struct: true</code>)</li>
</ul>
