<h1>Note: Some rust lifetime and borrow checkers 2020-07-11</h1>
<h5>1. lifetime</h5>
<p>scope that a given reference is valid. Or scope that a entity is not destructed.</p>
<h5>2. borrow checker</h5>
<p>compile time analysis to make sure no reference are invalid</p>
<h5>3. what does borrow checker check?</h5>
<p>Mainly reference. In C all dangling ptrs happen from having alias of a entity but not know if it is valid or not.</p>
<h5>4. how do I know the lifetime of something?</h5>
<p>Check the scope. If a reference is used when the value it points to is dropped it's a dangling reference.</p>
<h5>5. What's the point of lifetime parameter?</h5>
<p>Tell compiler the lifetime of a reference. In case it cannot inference.</p>
<h5>6. When can a compiler infer the lifetime?</h5>
<p>If it's within one scope you can easily tell if a reference is valid. But when a function take references as parameter it is hard for compiler to tell.</p>
<h5>7. But why compiler can't tell the life time of its parameter?</h5>
<p>All compiler can know is in runtime it will receive a reference, but it has know information about how long the value the reference point to will live.  The problem is more obvious when there are multiple references parameter.  Like if the function do something with one of the reference and return it back how long will it live.</p>
<h5>8. Consequence of dangling pointer?</h5>
<p>Reading any system programming materials you always see people say &quot;dangling pointer bad&quot;, &quot;avoid dangling pointers&quot;, but what harm do they do exactly? The most straight forward answer is core dump, but is there ways to rewind from a core dump? And if a pointer is dangling and not used by anybody then isn't it just chilling there and do nothing? I guess knowing how bad the problem can be is the only way to know how useful borrow checker really is.</p>
<p>Assume you have a pointer point to some object on heap. The heap is deallocated by the pointer is still accessible.</p>
<ul>
<li>If you never use it again, the dangling pointer hardly cause any problem.</li>
<li>If you deref it, depends on the language you can either catch it as exceptions (most gc languages), core dump directly (c), or UB (c++).</li>
<li>In c and c++ you have no way to rewind the execution, meaning if you deref a dangling pointer everything crash.</li>
<li>If your program is crashed by a core dump, no error messages are printed. Partially because this system language at runtime wouldn't have information of source code, and it's a hard termination without control like <code>panic</code>, so there is no way to insert error message either.</li>
<li>You don't know what cause the problem, and there is no error messages at all. It's very hard to find where didn't you deref the null pointer. At this point you probably need to break out gdb to step through and test upon which point your program stil runs.</li>
<li>The problem cause more trouble if you have multiple threads. Which thread should you step through anyway.</li>
<li>Because if a pointer is dangling pointer or not totally depends on the state of the program. A valid pointer at this point can suddenly invalidated in the next tick. If you have multiple mutable pointers this problem is very hard to track.</li>
<li>A potential null pointer might be used very often in the project, which propagate the uncertainty everywhere. Eventually every part of dereferencing can have dangling pointer, at that point just rewrite everything.</li>
</ul>
<h5>9. What if I want a reference be able to be nothing so I know it's not ready or something?</h5>
<p>Use <code>Option&lt;T&gt;</code> then. It's a (Maybe a) like <code>Enum</code> with null optimization, arguably small overhead. and safer.</p>
<h5>10. Why structs might have lifetime parameter?</h5>
<p>struct need lifetime parameter when it holds references. Essentially the struct is referencing something that it doesn't have, and the validity of the reference depends on the owner of the value.<br>
If a struct has multiple references it probably needs more precise lifetime parameter to assign a lifetime to each of them, so that they wouldn't collide</p>
<h5>11. how do you interpret lifetime parameter?</h5>
<p><strong>example 1</strong></p>
<pre><code class="language-rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span></span> {}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span>&lt;<span class="hljs-symbol">'a</span>&gt; {
    ref1: &amp;<span class="hljs-symbol">'a</span> B
}
</code></pre>
<p>means the struct A holds the reference of B which will life at least as long as lifetime <code>'a</code>. This implies if <code>*ref1</code> will always available during the lifetime of A.</p>
<p><strong>example 2</strong></p>
<pre><code class="language-rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span>&lt;<span class="hljs-symbol">'a</span>&gt; (&amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">i32</span>);
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span></span>&lt;<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'b</span>&gt;(&amp;<span class="hljs-symbol">'a</span> A&lt;<span class="hljs-symbol">'b</span>&gt;);

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> z = <span class="hljs-number">100</span>;
    <span class="hljs-keyword">let</span> z1 = (B(&amp;A(&amp;z)).<span class="hljs-number">0</span>).<span class="hljs-number">0</span>;
}
</code></pre>
<p>lifetime parameter of struct A is similar to the one above. For B, it has two lifetime parameter, which represents different lifetime respectively. It implies it holds a reference to A with lifetime 'a, and reference of A has a lifetime 'b which is different from its reference.</p>
<p>let's first say z has lifetime 'a1<br>
Looke at the main functoin, A(&amp;z) is created as temporary and is borrowed, and it will get dropped at the end of the statement.</p>
<p>say A(&amp;z) has lifetime 'a2</p>
<p>just look at the code you know 'a1 &gt; 'a2.</p>
<p>According to <code>struct B&lt;'a, 'b&gt;(&amp;'a A&lt;'b&gt;)</code>, the reference hold in B has different lifetime with the reference A holds. So it implies z and and A(&amp;z) lives in different lifetime</p>
<p>if B become <code>struct B&lt;'a&gt;(&amp;'a A&lt;'a&gt;)</code>, in which only has one lifetime parameter, A(&amp;z) and z will have the same lifetime. Because A is dropped at the end of the statement, it's reference to z should no longer be able to be accessed. But z comes from somewhere else and we know it is alive after the statement. To express that you need two different lifetime parameters.</p>
<h5>12. Conclusion of example above</h5>
<p>lifetime parameter in <code>struct&lt;&gt;</code> is not specify the lifetime of the struct, it is just an annotation to determine if lifetime of some reference are the same or different.</p>
<h5>13. If lifetime parameter only indicate lifetimes are same or not same, how about which lifetime is longer?</h5>
<p>analyse the example above</p>
<pre><code class="language-rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span>&lt;<span class="hljs-symbol">'a</span>&gt; (&amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">i32</span>);
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span></span>&lt;<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'b</span>&gt;(&amp;<span class="hljs-symbol">'a</span> A&lt;<span class="hljs-symbol">'b</span>&gt;);

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> z = <span class="hljs-number">100</span>;
    <span class="hljs-keyword">let</span> z1 = (B(&amp;A(&amp;z)).<span class="hljs-number">0</span>).<span class="hljs-number">0</span>;
}
</code></pre>
<p><strong>1</strong><br>
z has the longest lifetime 'a1<br>
A(&amp;z) has lifetime 'a2<br>
B(&amp;A(&amp;z)) has lifetime 'a3</p>
<p><strong>2</strong><br>
in fact you know 'a2 and 'a3 are the same, they only live in the statement.<br>
but 'a1 is different,<br>
in struct A it has lifetime 'a and in struct B it has lifetime 'b</p>
<p><strong>3</strong><br>
imagine you are compiler, you look at the definition, and figure:<br>
if they have the same lifetime parameter <code>struct B&lt;'a&gt;(&amp;'a A&lt;'a&gt;)</code>, then when b is<br>
dropped the referece should not be able to be accessed, and concequently the reference<br>
in A should not be able to be accessed.</p>
<p>But know, you see lifetime parameter of A ('b) in B is different from it's reference ('a).<br>
which means the reference has different life time as the reference contained in A.</p>
<p>So when B is dropped, the reference should not be able to be accessed. but the reference<br>
hold in A doesn't follow the same lifetime rule.</p>
<p>so what does it follow? There are two possibility:</p>
<ol>
<li>'b is longer than 'a. Then you can still access the reference even if B is dropped.</li>
<li>'b is shorter than 'a. It means the reference in A doesn't life as long as A, AKA, dangling pointer.  you will not have it. since if you have a struct you always at least specify the lifetime of it's reference is as long as the struct.</li>
</ol>
<h5>14. But how exactly does compiler ensure lifetime of reference is at least the same as the struct?</h5>
<p>In case of (<code>'b</code> is shorter than <code>'a</code>), say you have a struct <code>struct B&lt;'a, 'b&gt; (&amp;'a A&lt;'b&gt;)</code> A as lifetime a, and A's reference has lifetime <code>b</code>.<br>
But when you're defining A as <code>struct A&lt;'a&gt; (&amp;'a i32)</code>, it's reference has the same lifetime as the struct itself.<br>
This means the only valid struct is <code>'b &gt; 'a</code>, so that the reference A holds life at least as long as itself. If it's another case it is not valid in the first place.</p>
<p>so I guess if compiler see two different lifetime parameter it will only infer one is longer than the other. Since you have no way to express a struct hold a reference which lives shorter</p>
<h5>15. What is anonymous lifetime?</h5>
<p>For some common cases you don't need to specify the lifetime parameter. Compiler will follow the (lifetime elision) rule to assign lifetime for you.</p>
<h5>16. How do compiler do that?</h5>
<p>lifetime parameter for some common patterns is deterministic.</p>
<h5>17. Lifetime elision rule?</h5>
<p>rustc will follow the algorithm with three steps to determine if lifetime can be infered or not.</p>
<ol>
<li>It will assign all parameter with different lifetime parameter. Input lifetime is the lifetime of parameters. Output lifetime is the lifetime of the return value.</li>
<li>If there is exactly one input lifetime then the lifetime is assigned to output lifetime. for example: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code></li>
<li>If there are multiple input lifetime but one of them is &amp;self or &amp;mut self, then the lifetime of self is assigned to output parameter.</li>
</ol>
<h5>18. Rationale of lifetime elision rules?</h5>
<p>It is emperical, but you can somewhat explain it.</p>
<p>First step is just part of the algorithm. If the second and third steps finished but there are still incoherent amount of input lifetime and output lifetime then you cannot have anonymous lifetime parameter.</p>
<p>if there is only one reference, one case is you create a value on heap and return the reference of it, in which case the ownership of the value is Box&lt;T&gt;, which has it's lifetime. Another is you want to do something with the input reference and return it back. In such case the output can only have the same lifetime as the input parameter.</p>
<p>Third rule is for methods. If you have a method it always take self as parameter, and everything it produces works around the lifetime of self.<br>
For special case:<br>
e.g 1<br>
fn foo&lt;'a, 'b&gt;(&amp;'a self, &amp;'b ref: i32) -&gt; ?<br>
There might be cases that you want to return ref, but most of the time you want<br>
e.g 2<br>
fn foo&lt;'a&gt;(&amp;'a self, &amp;'a ref: i32) -&gt; ?<br>
It's a way to make method easier to write</p>
<h5>19. does lifetime elision rule capture all the cases?</h5>
<p>No, you can have function signature that does different thing, like e.g 1.<br>
if you do <code>fn foo&lt;'a, 'b&gt;(&amp;'a self, &amp;'b ref: i32) -&gt; &amp;'b ref</code><br>
It behaves differently from what type elision specifies. But compiler will see the lifetime parameter and know<br>
it should follow the signature rather than apply the elision rule.</p>
