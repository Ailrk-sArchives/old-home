<h1>Some llvm-hs</h1>
<h2>Overview</h2>
<p>LLVM is designed to be as modular as possible, as long as a binding can bind all the apis, you can have the full contorl over llvm. There is an official llvm ocaml binding, and that's what rust was initially written in. <code>llvm-hs</code> is the haskell equivalence of ocaml llvm binding. To use <code>llvm-hs</code> you need two libraries: <code>llvm-hs</code> and <code>llvm-hs-pure</code>. <code>llvm-hs-pure</code> provides pure types and functions for haskell to interact with llvm; <code>llvm-hs</code> use with FFI binding to llvm.</p>
<p>Once you have the IR representation you can choose either generate obeject code or jit compile the module.</p>
<p>To interact with the llvm library requires you first have the c++ representation of an LLVM Module. This needs you to construct the IR with <code>llvm-hs-pure</code> first, then convert it to c++ representation with <code>withModuleFromAST</code> in <code>llvm-hs</code>.</p>
<pre><code>-- possible work flow.

`llvm-pure-hs` -> IR haskell representation -> `llvm-hs` -> IR c++ representation -> `withModuleFromAST` -> gen
</code></pre>
<p>Also you can choose to eitehr generate object code or jit compile.</p>
<h2>llvm-hs-pure</h2>
<p><code>llvm-hs-pure</code> provides an algebraic data type representation of LLVM IR, and some handy utils to work with IR. No actual llvm binding here.</p>
<h4>LLVM.AST</h4>
<p>List of some noticable structure.</p>
<pre><code>    Module ← Definition ← & Global ← BasicBlock ← Instruction ← Operand ← `Constant`
                          & Type ←
</code></pre>
<h5>Module</h5>
<p>A <code>Module</code> has some meta data plus a list of <code>Definition</code>. A <code>Definition</code> contains anythings that can be at the top level of a LLVM Module. For instance, global, type definition, function attributes etc.</p>
<h5>Global</h5>
<p>There are some build in default <code>Global</code>s, namely <code>globalVariableDefaults</code>, <code>globalAliasDefaults</code>, <code>functionDefaults</code>. They are designed to helo make <code>Global</code> easier.</p>
<h5>BasicBlock</h5>
<p>LLVM code in a function is a sequence of <code>BasicBlock</code>s, each one has their own label, some instructions, and a terminator. <code>BasicBlock</code> contains <code>Instruction</code>, which is defined in <code>LLVM.AST.Instruction</code></p>
<h5>Instruction</h5>
<p><code>Instruction</code> represent non-terminator instructions like <code>%result = add i32 %1, %b</code>. These instructions are defined in llvm IR, you cannot make whatever. <code>Instruction</code> contains <code>Operands</code>, which serves as parameter to the instruction.</p>
<h5>Terminator</h5>
<p>In contrast with <code>Instruction</code>, <code>Terminator</code> are instruction that ends a basic block. Such terminator can be <code>ret</code>, <code>br</code>, <code>swithc</code>, <code>invoke</code> etc.</p>
<p>Note for <code>invoke</code> there is an option called <code>CallingConvention</code>, which allows you to decide what calling convention to use.</p>
<h5>Operand</h5>
<p><code>Operand</code> is used by <code>Instruction</code>, and it contains <code>Constant</code>. Note there is also <code>CallableOperand</code> which can be invoked by <code>Instruction</code> <code>Call</code>  <code>Call</code> is a non-terminator.</p>
<h5>Constant</h5>
<p>Defined in <code>LLVM.AST.Constant</code>. Constant contains stuffs like <code>Int { intergerBits :: Word32, integerValue :: Integer}</code>.</p>
<h5>Type</h5>
<p>Define some elements of the LLVM type system.</p>
<h4>LLVM.IRBuilder</h4>
<p><code>IRBuilder</code> helps reduce the verbosity of dealing with AST directly.</p>
<h5><code>IRBuilderT m a</code></h5>
<p>Mtl that helps you to create instruction and insertingthem into a basic block at any location.</p>
<h5><code>block :: MonadIRBuilder m =&gt; m Name</code></h5>
<p>Starts a new block and ends the previous one</p>
<h5><code>currentBlock :: MonadIRBuilder m =&gt; m Name</code></h5>
<p>Get the name of the current active block.</p>
<h2>llvm-hs</h2>
<p><code>llvm-hs</code> build on top of llvm and it is the actual biding of llvm library. It provides bidirectional conversions between haskell representation of a module to c++ representation.</p>
<h4>LLVM.Module</h4>
<h5><code>Module</code></h5>
<p>Binding to c++ representation of Module. On the haskell side it will be represented as LLVM.AST.Module</p>
<h5><code>File</code></h5>
<p>A newtype used to distinguish string for path from other strings.</p>
<h5><code>Context</code></h5>
<p>Context object holds the state of LLVM system needs for one threaed of LLVM compilation. Multiple conetxt allows multiple threads to compile at once.</p>
