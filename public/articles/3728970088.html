<h3>Summary of 2020, floor</h3>
<p>Thinking back of 2020 is like tunneling through a timemachine: so many things have happened, yet everything feels like in yesterday. I still remember how the corona virus causing a panic in the January, all the sudden it has been the end of the year. Initially I was planning to make it a long chronological report, but soon I realize it's impossible to list everything. So I guess I'll just make it a brief summary of what I learnt in this year.</p>
<h4>What I learnt in the past</h4>
<p>Instead of specific things, I feel several general observations are more worthwhile to be stated in a year summary. These are from my personal experience, despite being super cliche, I think they are important.</p>
<h5>Don't hype things too early</h5>
<p>First thing I learnt is that hypes doesn't last very long, and the real value of something comes when the hype died down. It's very easy to get over excited when learning new stuffs: it feels like you unlock the secret of some truth. But in reality, you just learnt another way to skin the cat, normally with different trade offs. A specific example: I was learning monad transformer earlier in the year. The idea is stacking transforms to form a giant aggregated monad. Doing so you can represent multiple effects in the type explicitly. I was super excited in the first several days, and thought it's the superior way to manage effects. But when I need to wrap one up myself, all hell breaks loose: I need to care about the order of layers, I need to know how to unwrap the stack. If I want to access a deeply nested layer do I need <code>lift . lift . lift</code>? MTL saves you from lifting like crazy, but now you have n square instances problem. Anyone who uses monad transformer daily knows the ergonomic is not ideal, otherwise there won't be endeavors on effect systems. I guess some problems you just can't see until you reach certain familiarity, and you can't claim you understand something until you see problems come with them.</p>
<h5>Sleep more!</h5>
<p>Sleeping is crucial. My sleeping schedule was terrible, and it was especially ridiculous in the last year. I irregularly had 20 hours wake time, sleep for 4 hours, buy an A&amp;W large coffee and start a new day. This caused a problem several days before, that I couldn't sleep at night, but sleep excessively during the day time, which was quite scary. I feel the mindset behind staying up late is to trade sleeping time with productivity, but now I realize you're just that productive each day, working excessively won't make more work done, but only damage the efficiency in a long run. Insufficient sleep means you can't focus on the day, so you take much longer time to do things, which takes away your sleeping time... It's recursive. To break the loop, a fixed schedule is very important. But what to do when there is a deadline tomorrow? I guess in that case just don't let the situation happen in the first place. Do it days earlier or something. Anyway, this is the root of most of my problems, and it might be the most urgent one to fix, since it can literally kill me sooner or later...</p>
<h5>When in doubt, read more stuffs</h5>
<p>When you feel you think too much and start to make things up, it's about time to learn something new. The motive for this one is again from Haskell. The language felt very encrypted at the first glance, and because of the hyping problem stated above, you start to fantasize characteristics that it doesn't possess. I once thought Haskell's abstraction mechanism is so powerful that I shouldn't expect to write a line of boilerplate, everything can be derived or be abstracted out. Of course it's a hallucination I made up. People keep selling it, but the common way for libraries to provide pre-built instances is to implement for all common types. Thought lots of these instance are exactly the same, you can't share the code. This bugged me for quite a while, where is the promised elegance? Now I know to avoid boilerplates you have either template Haskell or Generics, but people still hand write instance for better performance. To answer the question, you need to be aware of generic programming, template meta programming, why people don't like templates in Haskell, and why Generics is less efficient than hand written instance. Is pretty unlikely for you to deduce the right answer by yourself, so searching for reason feels so important here. On the internet you can see people who think too much without learning make false statements, and people who learnt too much without understanding what they learnt. I think it's important to be aware of this problem, and whenever get confused, assure yourself keep learning and things will eventually make sense.</p>
<h5>Make things simple</h5>
<p>Fourth, complicated techniques is not the goal but the means, so If a thing can be done with simple method one should always prefer the simplest one. All problems have their inherent complexity. For instance, you want to implement a sorting algorithm with O(nlogn) complexity. The first option is to implement a merge sort with an entry function and several helpers, simple. If you decide to make the merge function a class which implements an merge interface, you're clearly over engineering. Extra complexities can be thought as money, if you pay the price, you expect something in return. Haskell uses monad for effects, which is definitely an extra layer of complexity. But the reward is pretty clear, you are finally able to express effect in a pure language. I'm still in the stage of playing will fancy language features. Typical syndromes are: making excessive use of template in C++, adding bunch of language extensions in Haskell, trying to parallel a program that finish in 0.1s... Eventually you will know all of this things, they become part of your experience; the real value of experience is being able to know when to do what.</p>
<h5>If you need anything just speak up</h5>
<p>Fifth, communication matters. At the beginning of the year I spent large amount of time working on the web platform for Chongqing University. It was a really nice work experience, but I think I made a lot of mistakes on the go. The biggest problem I had is probably communication. I need to make a RESTFUL based website for the University, but because of a lot of reasons, I can't talk with people from the University directly. Instead, if I need to know anything about the requirement, I need to ask the IT company that contracted with the University, and use them as a proxy to communicate. It became extremely hard to get API information I need. When reporting the progress, the &quot;man in the middle&quot; usually deliver the wrong message because he don't really know anything about the project. It felt like shotting in the dark. These inefficient communication last for 3 months, because I can't get what I need constantly, 50% of my time was wasted on testing the behavior of the API. In this case the goal is to finish the job efficiently, and to do so a direct communication is necessary. I could have call the company to let me have direct contact with the Univeristy, but I didn't do anything because no one felt it's a problem. I guess doing nothing is also a sin. If you need something just speak out, at least let people know it.</p>
<h5>2021</h5>
<p>It's really hard to conclude an entire year in one article. It took me quite while to finish this summary, and it turned out to be a collection of rants. I don't dare to make a plan for 20201, because a plan takes a good amount of effort to realize, and I can't guarantee anything before they come to me. Anyway, here are my take from 2020. Wish everyone has a wonderful 2021.</p>
